#!/usr/bin/env python
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""fMBT stats tool - print statistics from test log

Usage: fmbt-stats [options] [logfile]

logfile is the XML log written by fmbt (fmbt -l logfile test.conf),
adapter logs are not supported.

Options:
  -f, --format=<fmt>
          fmt defines statistics to present. Available formats:

          times[:field]     - execution times of test steps
              data is sorted by the field ("min", "max", "median",
              "total", "count" or "name").

          speed[:n[,n2...]] - test step execution speed
              average execution speed of previous n (n2, ...) actions.

          count[:split]     - number of executions of test steps
              split ("next", "prev") shows the number of next or previous
              steps. TODO

  -o, --output=<file>
          output will be written to given file. Defaults to the
          standard output. File extension defines output
          format. Supported formats: html, csv, txt (default).

  -h, --help
          print this help.

  -p, --plot=<file>
          plot statistics into a diagram. Image will be written to the
          given file. Requires Gnuplot. File extension defines image
          format. Supported formats: eps, gif, png, svg.

Examples:
  fmbt-stats -f times:median -p median.png test.log
  display median.png

  fmbt-stats -f times:total -o total.html -p total.svg test.log
  firefox total.html total.svg

  fmbt-stats -f speed:1,5 -o speed.csv -p speed.gif test.log
"""

import commands
import sys
import operator
import subprocess
import getopt
import os

def error(msg):
    sys.stderr.write('fmbt-stats: ' + msg + '\n')
    sys.exit(1)

def read_from_log_timestamp_execaction(testlog_fileobj):
    cmd = "fmbt-log -f '$st $ax'"
    p = subprocess.Popen(cmd, shell=True, stdin=testlog_fileobj.fileno(), stdout=subprocess.PIPE)
    out = p.communicate()[0]
    lines = out.split('\n')
    if out == []: error("empty output from \"%s\"" % (cmd,))

    timestamp_actionname_list = []
    for s_timestamp, s_actionname in [l.split(' ',1) for l in lines if l != '']:
        if s_timestamp.strip() == "" or s_actionname.strip() == "": continue
        timestamp_actionname_list.append((float(s_timestamp), s_actionname))
    return timestamp_actionname_list

def read_from_log_possible_executed(testlog_fileobj):
    cmd = "fmbt-log -f 'p:$am\nx:$ax'"
    p = subprocess.Popen(cmd, shell=True, stdin=testlog_fileobj.fileno(), stdout=subprocess.PIPE)

    possible_actions = []
    executed_actions = []
    line = p.stdout.readline()
    while line:
        if line[0]=='x' and len(line) > 3:
            executed_actions.append(line[2:-1])
        elif line[0]=='p' and len(line) > 3:
            possible_actions.append(line[2:-1])
        line = p.stdout.readline()
    if possible_actions == []: error("empty output from \"%s\"" % (cmd,))
    return possible_actions, executed_actions

def check_output_format(output_fileobj):
    """return csv, html or plot"""
    if '.' in output_fileobj.name: output_file_ext = output_fileobj.name.split('.')[-1].lower()
    else: output_file_ext = ""

    if output_file_ext in ['html', 'csv']: output_file_format = output_file_ext
    else: output_file_format = 'plot'
    return output_file_format


def init_plotting(plot_filename, plot_data_table):
    """return set term parameter and plot data filename"""
    plot_output_format = plot_filename.split('.')[-1] if '.' in plot_filename else plot_filename
    if plot_output_format in ['gif', 'png']:
        plot_output_format = plot_output_format + ' size 1024,768 10 xffffff'
    elif plot_output_format in ['svg']:
        plot_output_format = plot_output_format + ' size 1024,768 fsize 10'
    elif plot_output_format in ['ps', 'eps']:
        plot_output_format = 'postscript landscape "Helvetica" 10'
    elif plot_output_format in ['pdf']:
        plot_output_format = 'pdfcairo'
    output_filename = "/tmp/fmbt-stats.%s.dat" % (os.getpid(),)

    file(output_filename, "w").write("".join(plot_data_table))
    return plot_output_format, output_filename

def finish_plotting(plot_datafilename, gnuplot_commands):
    gnuplot_process = subprocess.Popen("gnuplot", shell=True, 
                                       stdin=subprocess.PIPE)
    gnuplot_process.communicate(gnuplot_commands)
    os.remove(plot_datafilename)

def stats_speed(arg, testlog_fileobj, output_fileobj, plot_filename):

    try: averages = [int(a) for a in arg.split(',')]
    except: error("syntax error in speed arguments, expected integer[, integer...]")
    
    def format_data(out_format, data_speed_columns):
        if len(data_speed_columns) == 0: return []
        title = 'Average execution speed [test steps / s]'

        column_count = len(data_speed_columns[0])
        header_format, datarow_format, footer_format = {}, {}, {}
        header_format['plot'] = '# ' + title + '\n#' + (' '.join(['%11s' for _ in xrange(column_count)])) + '\n'
        datarow_format['plot'] = ('%11.3f ' * column_count) + '\n'
        footer_format['plot'] = ''

        header_format['csv'] = '"' + title + '"\n' + ';'.join(['"%s"' for _ in xrange(column_count)]) + '\n'
        datarow_format['csv'] = ';'.join(['%.3f' for _ in xrange(column_count)]) + '\n'
        footer_format['csv'] = ''

        header_format['html'] = '<html><body>\n<h2>' + title + ('</h2>\n<table>\n<tr><th>%s</th>' % ('</th><th>'.join(["%s" for _ in xrange(column_count)])))
        datarow_format['html'] = '<tr><td>%s</td></tr>\n' % ('</td><td>'.join(["%.3f" for _ in xrange(column_count)]),)
        footer_format['html'] = '</table></body></html>\n'

        header_row = tuple(["%s step(s)" % (n,) for n in averages])

        output_table = [header_format[out_format] % header_row]
        for datarow in data_speed_columns:
            output_table.append(datarow_format[out_format] % tuple(datarow))
        output_table.append(footer_format[out_format])
        return output_table

    timestamp_action_list = read_from_log_timestamp_execaction(testlog_fileobj)

    data = []
    for i in xrange(min(averages), len(timestamp_action_list)):
        this_timestamp = timestamp_action_list[i][0]
        data.append([])
        for avg in averages:
            if avg > i: avg = i
            prev_timestamp_avg = timestamp_action_list[i-avg][0]
            data[-1].append( avg/(this_timestamp-prev_timestamp_avg) )

    output_file_format = check_output_format(output_fileobj)

    output_table = format_data(output_file_format, data)
    output_fileobj.write("".join(output_table))
    output_fileobj.close()

    if plot_filename:
        plot_term, plot_datafilename = init_plotting(plot_filename,
                                                     format_data('plot', data))
        plot_columns = []
        for column in xrange(len(data[0])):
            plot_columns.append(
                "'%s' using :%s title \"%s step(s)\"  with lines" % (
                    plot_datafilename, column + 1, averages[column]))
        gnuplot_commands = """
set ylabel "Average execution speed [test steps / s]"
set xlabel "Test step"
set log y
set term %(format)s
set grid ytics noxtics
set output "%(plot_filename)s"
plot %(plot_columns)s
""" % { 'format': plot_term,
        'plot_filename': plot_filename,
        'plot_columns' : ','.join(plot_columns) }

        finish_plotting(plot_datafilename, gnuplot_commands)


def stats_times(arg, testlog_fileobj, output_fileobj, plot_filename):

    def format_data(out_format, min_med_max_tot_count_aname):
        title = 'Test step execution times'
        header_format, datarow_format, footer_format = {}, {}, {}
        header_format['plot'] = '# ' + title + '\n#%8s %9s %9s %9s %9s "%s"\n'
        datarow_format['plot'] = '%9.3f %9.3f %9.3f %9.0f %9s "%s"\n'
        footer_format['plot'] = ''

        header_format['csv'] = '"' + title + '"\n' + '%s;%s;%s;%s;%s;%s\n'
        datarow_format['csv'] = '%.3f;%.3f;%.3f;%.0f;%s;"%s"\n'
        footer_format['csv'] = ''

        header_format['html'] = '<html><body>\n<h2>' + title + '</h2><table>\n<tr><th>%s</th><th>%s</th><th>%s</th><th>%s</th><th>%s</th><th>%s</th></tr>\n'
        datarow_format['html'] = '<tr><td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.0f</td><td>%s</td><td>%s</td></tr>\n'
        footer_format['html'] = '</table></body></html>\n'

        header_row = ('min[ms]', 'med[ms]', 'max[ms]', 'total[ms]', 'count', 'action')

        output_table = [header_format[out_format] % header_row]
        for datarow in min_med_max_tot_count_aname:
            output_table.append(datarow_format[out_format] % datarow)
        output_table.append(footer_format[out_format])
        return output_table

    possible_args = ['min', 'median', 'max', 'total', 'count', 'name']
    if not arg in possible_args:
        error("unknown timer argument: '%s'. Use one of '%s'." %
              (arg, "', '".join(possible_args)))
    sort_by_field = possible_args.index(arg)

    action_exectimes = {} # map action name to list of exec time durations
    prev_timestamp = None
    for timestamp, actionname in read_from_log_timestamp_execaction(testlog_fileobj):
        if prev_timestamp != None:
            timedelta = timestamp - prev_timestamp
            if not prev_actionname in action_exectimes:
                action_exectimes[prev_actionname] = []
            action_exectimes[prev_actionname].append(timedelta)
        prev_timestamp = timestamp
        prev_actionname = actionname

    for a in action_exectimes:
        action_exectimes[a].sort()
    min_med_max_tot_count_aname = []
    for a in action_exectimes:
        exectimes = action_exectimes[a]
        min_med_max_tot_count_aname.append(
            (exectimes[0]*1000,
             exectimes[len(exectimes)/2]*1000,
             exectimes[-1]*1000,
             sum(exectimes)*1000,
             len(exectimes),
             a))
    min_med_max_tot_count_aname.sort(key=operator.itemgetter(sort_by_field, 4))

    output_file_format = check_output_format(output_fileobj)

    output_table = format_data(output_file_format, min_med_max_tot_count_aname)
    output_fileobj.write("".join(output_table))
    output_fileobj.close()

    if plot_filename:

        plot_term, plot_datafilename = init_plotting(plot_filename,
                                                   format_data('plot', min_med_max_tot_count_aname))

        gnuplot_commands = """
set ylabel  "Execution times [ms]: min-median-max (red), total (blue)"
set y2label "Number of iterations (grey bar)"
unset key
set xtics rotate by -15
set log y
set log y2
set pointsize 1
set grid ytics mytics noxtics
set term %(format)s
set output "%(plot_filename)s"
set boxwidth 0.2
plot [-1:] '%(plot_datafilename)s' using :5 with boxes fill solid 0.5 linecolor rgb "light-grey", '%(plot_datafilename)s' using :2:1:3:xtic(6) with errorbar pointtype 2 linecolor rgb "red", '%(plot_datafilename)s' using :4 with points pointtype 6 linecolor rgb "blue"
""" % {'plot_filename': plot_filename, 
       'plot_datafilename': plot_datafilename,
       'format': plot_term}

        finish_plotting(plot_datafilename, gnuplot_commands)


def stats_count(arg, testlog_fileobj, output_fileobj, plot_filename):
    possible_actions, executed_actions = read_from_log_possible_executed(testlog_fileobj)

    def format_data(out_format, data_dict):
        action_columns = sorted(data_dict.keys())
        header_format, datarow_format, footer_format = {}, {}, {}

        if out_format != "plot": raise NotImplemented
        output_table = [""]
        for a in action_columns:
            output_table[0] += '"' + a + '" '
        output_table[0] += "\n"
        for prev in action_columns:
            data_row = []
            for next in action_columns:
                data_row.append(data_dict[prev].get(next, 0))
            data_row.append('"' + prev + '"\n')
            output_table.append(" ".join([str(i) for i in data_row]))
        return output_table
    # Create data dictionary:
    # { possible action_1 -> { next_action_1: count_1,
    #                          next_action_2: count_2,
    #                          ... }
    #   ...
    # }
    data = {}
    for a in possible_actions:
        data[a] = {}
    if executed_actions:
        prev = executed_actions[0]
        if arg == "next":
            for next in executed_actions[1:]:
                data[prev][next] = data[prev].get(next, 0) + 1
                prev = next
        elif arg == "prev":
            for next in executed_actions[1:]:
                data[next][prev] = data[next].get(prev, 0) + 1
                prev = next
        elif arg == "":
            for act in executed_actions:
                data[act][act] = data[act].get(act, 0) + 1
        else:
            error('unknown count argument "%s".' % (arg,))

    if plot_filename:
        plot_term, plot_datafilename = init_plotting(plot_filename,
                                                     format_data('plot', data))
        gnuplot_commands = """
set term %(format)s
set output "%(plot_filename)s"

set boxwidth .8
set style fill solid 1.00 border lt -1
set key outside right top vertical Left reverse noenhanced autotitles columnhead nobox
set key samplen 4 spacing 1 width 0 height 0
set style histogram rowstacked title offset character 0, 0, 0

set xtics border in scale 0,0 nomirror rotate by -25  offset character 0, 0, 0
set xtics  norangelimit font ",8"
set style data histograms
plot '%(plot_datafilename)s' using 1:xtic(%(actioncol)s), for[i=2:%(lastdatacol)s] '' using i
""" % {'plot_filename': plot_filename, 
       'plot_datafilename': plot_datafilename,
       'format': plot_term,
       'lastdatacol': len(possible_actions),
       'actioncol': len(possible_actions)+1
       }

        finish_plotting(plot_datafilename, gnuplot_commands)
    

if __name__ == '__main__':
    testlog_fileobj = sys.stdin
    output_fileobj = sys.stdout
    output_format = 'times:total'
    plot_filename = None

    opts, remainder = getopt.getopt(
        sys.argv[1:], 'hf:o:p:',
        ['help', 'format=', 'output=', 'plot='])
    for opt, arg in opts:
        if opt in ['-h', '--help']:
            print __doc__
            sys.exit(0)
        elif opt in ['-f', '--format']:
            output_format = arg
        elif opt in ['-o', '--output'] and not arg in ['', '-']:
            output_fileobj = file(arg, 'w')
        elif opt in ['-p', '--plot']:
            plot_filename = arg

    if remainder and remainder[0] != "-":
        testlog_fileobj = file(remainder[0], "r")

    if output_format.startswith('times'):
        if ':' in output_format:
            param = output_format.split(':',1)[1]
        else:
            param = 'total'
        t = stats_times(param, testlog_fileobj, output_fileobj, plot_filename)

    elif output_format.startswith('speed'):
        if ':' in output_format:
            param = output_format.split(':',1)[1]
        else:
            param = '1'
        t = stats_speed(param, testlog_fileobj, output_fileobj, plot_filename)
    
    elif output_format.startswith('count'):
        if ':' in output_format:
            param = output_format.split(':',1)[1]
        else:
            param = '2'
        t = stats_count(param, testlog_fileobj, output_fileobj, plot_filename)
        
    else:
        error('unknown format: %s' % (output_format,))
