#!/usr/bin/env python
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""
Usage: remote_pyaal [options] aalfile

Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc.

Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L appends.

    -t, --timeout s
        Event observation timeout in seconds.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    -d, --debug
        Run in debug mode.
"""

import sys
import os
import getopt
import commands
import time
import fmbt
import atexit
import urllib
import traceback

sys.path.append(os.getcwd())

opt_debug = False

log_filename = None
log_flush_interval = 1.0 # in seconds
def _log(msg, flush=False):
    global log_filename
    if opt_debug:
        file(log_filename,"a").write(fmbt.formatAdapterLogMessage(msg))
        return
    current_time = time.time()
    if log_filename:
        _log.messages.append(fmbt.formatAdapterLogMessage(msg))
        if flush or current_time - _log.last_flush > log_flush_interval:
            file(log_filename,"a").write(''.join(_log.messages))
            _log.last_flush = current_time
            _log.messages = []
_log.messages = []
_log.last_flush = time.time()

def fmbtlog(msg, flush=True):
    current_time = time.time()
    timestamped = "l%.4f %s" % (current_time, msg)
    sys.stdout.write(urllib.quote(timestamped)+"\n")

def fmbtstderr(msg):
    to_fmbt = urllib.quote("e%s" % (msg,)) + '\n'
    sys.stdout.write(to_fmbt)
    _log(msg)

fmbt.fmbtlog = fmbtlog
fmbt.adapterlog = _log
log = _log

def error(msg):
    msg = "remote_pyaal error: " + msg + "\n"
    _log(msg)
    sys.stderr.write(msg)
    sys.exit(1)

def bye():
    _log("quitting", flush=True)
atexit.register(bye)

def put(msg):
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write(str(msg) + "\n")
    sys.stdout.flush()

def put_list(list_of_integers):
    msg = " ".join([str(i) for i in list_of_integers])
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write(msg + "\n")
    sys.stdout.flush()

def get():
    cmd = sys.stdin.readline().rstrip()
    if opt_debug: _log("received: '%s'" % (cmd,))
    return cmd

class RemoteAALBridge:
    def __init__(self, aal):
        self._aal = aal

    def communicate(self):
        # send all action names
        action_names = self._aal.getActionNames()
        for name in action_names:
            put(name)
        put("")

        # send all state tags
        tag_names = self._aal.getSPNames()
        for name in tag_names:
            put(name)
        put("")

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != "":
            if cmd == "ma":
                try:
                    put_list(self._aal.getActions())
                except Exception, e:
                    fmbtstderr("%s" % (e,))
                    error(str(e))
            elif cmd == "mp":
                put_list(self._aal.getprops())
            elif cmd == "mr":
                try:    self._aal.reset()
                except Exception, e:
                    fmbtstderr('Error at initial_state(): %s: %s\n%s' % (type(e).__name__, e, traceback.format_exc()))
                    put(0)
                else:   put(1)
            elif cmd == "mu":
                self._aal.push()
            elif cmd == "mo":
                self._aal.pop()
            elif cmd == "aop":
                try:
                    put_list(self._aal.observe(False))
                except Exception, e:
                    fmbtstderr('Error when polling outputs: %s: %s\n%s' % (type(e).__name__, e, traceback.format_exc()))
                    put_list([])
            elif cmd == "aob":
                try:
                    put_list(self._aal.observe(True))
                except Exception, e:
                    fmbtstderr('Error when waiting for outputs: %s: %s\n%s' % (type(e).__name__, e, traceback.format_exc()))
                    put_list([])
            elif cmd[0] == "m":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.model_execute(action_number)
                except Exception, e:
                    fmbtstderr('Error at body() of "%s": %s: %s\n%s' % (action_names[action_number-1], type(e).__name__, e, traceback.format_exc()))
                    put(0)
                else:
                    put(rv)
            elif cmd[:2] == "ap":
                adapter_call_arguments.append(cmd[2:])
            elif cmd[0] == "a":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.adapter_execute(action_number,
                                                   adapter_call_arguments)
                except Exception, e:
                    fmbtstderr('Error at adapter() of "%s": %s: %s\n%s' % (action_names[action_number-1], type(e).__name__, e, traceback.format_exc()))
                    put(0)
                else:   put(rv)
                adapter_call_arguments = []
            else:
                error("Unexpected command: \"" + cmd + "\". remote_pyaal works with \"aal_remote\" model.")
            cmd = get().rstrip()

def aal2lsts(aal, output_fileobj, depth=5, discard_variables=set([]), include_variables=None):
    try:
        import lsts
    except:
        import fmbt.lsts as lsts

    generation_discontinued_tag = "AAL-depth:%s" % (depth,)

    new_lsts = lsts.writer()
    actionnames = ["tau"] + aal.getActionNames()
    # actionname2int = dict([(action, num) for num, action in enumerate(actionnames)])
    transitions = [[]]
    tags = {generation_discontinued_tag: []}
    tags.update([(name, []) for name in aal.getSPNames()])
    tagnum_to_name = dict([(num+1, name) for num, name in enumerate(aal.getSPNames())])

    aal.reset()
    initial_state_hidden = aal.state(discard_variables, include_variables)
    initial_state_real = aal.state()
    unhandled_states = {initial_state_real: []} # state to shortest path from istate
    found_states_real = {initial_state_real: initial_state_hidden} # real to hidden states
    lsts_states = {initial_state_hidden: 0} # state to LSTS state number
    states = 1

    # initial state tags
    for tag in aal.getprops():
        tags[tagnum_to_name[tag]].append(lsts_states[initial_state_hidden])

    while unhandled_states:
        source_state, path = unhandled_states.popitem()
        source_lsts_state = lsts_states[found_states_real[source_state]]

        if len(path) >= depth:
            if not source_lsts_state in tags[generation_discontinued_tag]:
                tags[generation_discontinued_tag].append(lsts_states[found_states_real[source_state]])
            continue

        aal.push()
        for action in path:
            aal.model_execute(action)

        for action in aal.getActions():
            aal.push()
            aal.model_execute(action)
            next_state_real = aal.state()
            next_state_hidden = aal.state(discard_variables, include_variables)
            # new state?
            if not next_state_hidden in lsts_states:
                transitions.append([])
                lsts_states[next_state_hidden] = len(transitions) - 1
            if not next_state_real in found_states_real:
                unhandled_states[next_state_real] = path + [action]
                found_states_real[next_state_real] = next_state_hidden
                next_lsts_state_num = lsts_states[next_state_hidden]
                for tag in aal.getprops():
                    tagname = tagnum_to_name[tag]
                    if not next_lsts_state_num in tags[tagname]:
                        tags[tagname].append(next_lsts_state_num)
            if (lsts_states[next_state_hidden],action) not in transitions[source_lsts_state]:
                transitions[source_lsts_state].append((lsts_states[next_state_hidden],action))
            aal.pop()
        aal.pop()

    new_lsts.set_actionnames(actionnames)
    new_lsts.set_transitions(transitions)
    new_lsts.set_stateprops(tags)
    new_lsts.write(output_fileobj)

if __name__ == "__main__":
    # Default values for commandline arguments
    log_filename = None
    opt_timeout = 1.0
    opt_ppflags = ""
    opt_output_fileobj = None
    opt_lsts_depth = 5
    opt_lsts_hide_vars = []
    opt_lsts_show_vars = []
    opt_c_exec_statements = []

    # Parse arguments
    opts, remainder = getopt.gnu_getopt(
        sys.argv[1:], 'c:dhl:L:t:o:D:H:S:V',
        ["debug", "help", "log-file=", "timeout=", "output=", 
         "lsts-depth=", "lsts-hide-var=", "lsts-show-var=", "version"])

    for opt, arg in opts:
        if opt in ["-d", "--debug"]:
            opt_debug = True
        elif opt in ["-c"]:
            opt_c_exec_statements.append(arg)
        elif opt in ["-D"]:
            opt_ppflags += "'-D"+arg+"' "
        elif opt in ['-V', '--version']:
            try:
                import fmbt_config
                print "Version " + fmbt_config.fmbt_version
            except:
                print "Version N/A"
            sys.exit(0)
        elif opt in ["-h", "--help"]:
            print __doc__
            sys.exit(0)
        elif opt in ["-l", "-L", "--log-file"]:
            log_filename = arg
            if opt != "-L": file(log_filename, "w") # overwrite
        elif opt in ["-t", "--timeout"]:
            opt_timeout = float(arg)
            _log("observe timeout: %2.6f" % (opt_timeout,))
        elif opt in ["-o", "--output"]:
            if arg == "-":
                opt_output_fileobj = sys.stdout
            else:
                opt_output_fileobj = file(arg, "w")
        elif opt in ["--lsts-depth"]:
            opt_lsts_depth = int(arg)
        elif opt in ["-H", "--lsts-hide-var"]:
            opt_lsts_hide_vars.append(arg)
        elif opt in ["-S", "--lsts-show-var"]:
            opt_lsts_show_vars.append(arg)

    if len(remainder) != 1:
        print __doc__
        error("aal filename missing")
    
    aal_filename = remainder[0]

    if aal_filename.endswith(".aal"):
        cmd = "fmbt-aalc %s '%s'" % (opt_ppflags, aal_filename)
        status, aal_code = commands.getstatusoutput(cmd)
        if status != 0:
            fmbtstderr("AAL to Python conversion failed:\n%s" % (aal_code,))
            error("converting aal to python with command\n" +
                  "    %s\nfailed. status=%s" % (cmd, status))
    else:
        try:
            aal_code = file(aal_filename).read()
        except Exception as e:
            error("reading file '%s' failed: %s" % (aal_filename, e))

    for statement in opt_c_exec_statements:
        try:
            _log("Executing command line argument '%s'" % statement)
            exec statement
        except Exception, e:
            fmbtstderr('Exception from command line argument "%s":\n%s' %
                       (statement, traceback.format_exc()))
            error("No exceptions allowed, got '%s':\n%s" %
                  (e, traceback.format_exc()))

    try:
        exec aal_code
    except Exception as e:
        code_lines = aal_code.split('\n')
        code_with_line_nums = ['%4s: %s' % (num+1, line)
                               for num,line in enumerate(code_lines)]
        _log('\n'.join(code_with_line_nums))
        fmbtstderr("Executing %s failed: %s: %s" % (aal_filename, type(e).__name__, e))
        error("executing aal code failed:\n%s\n%s" % (e, traceback.format_exc()))

    try:
        # Generated AAL code exports generated AAL class as "Model".
        # Model is inherited from AALModel in aalmodel.py.
        aal = Model()
    except Exception as e:
        error("error when instantiating Model(): %s\n%s" % (e, traceback.format_exc()))
    aal._log = _log
    aal.timeout = opt_timeout
    aal._variables['fmbtlog'] = fmbtlog

    if not opt_output_fileobj:
        bridge = RemoteAALBridge(aal)
        _log("starting")
        bridge.communicate()
    else:
        aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars))
        opt_output_fileobj.close()
