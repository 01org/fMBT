#!/usr/bin/env python

#
# fMBT, free Model Based Testing tool
# Copyright (c) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

# This is a demo / prototype of an editor for fmbt-gt files.

import sys

def error(msg, exit_status = 1):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
    sys.exit(exit_status)

try:
    from PySide import QtCore, QtGui
    fallback_to_PyQt4 = False
except:
    try:
        from PyQt4 import QtCore, QtGui
        fallback_to_PyQt4 = True
    except:
        error("PySide or PyQt4 required.")

import subprocess
import commands
import re

PREVIEW_MODEL, PREVIEW_TEST, PREVIEW_DIST = range(3)
EDIT_GT, EDIT_CONF = range(2)

class MyScaleEvents(QtCore.QObject):
    def __init__(self, parent, attrowner, min_scale, max_scale):
        QtCore.QObject.__init__(self, parent)
        self.min_scale = min_scale
        self.max_scale = max_scale
        self.attrowner = attrowner
    def changeScale(self, coefficient):
        self.attrowner.wheel_scale *= coefficient
        if self.attrowner.wheel_scale < self.min_scale: self.attrowner.wheel_scale = self.min_scale
        elif self.attrowner.wheel_scale > self.max_scale: self.attrowner.wheel_scale = self.max_scale
        self.attrowner.wheel_scale_changed()
    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.KeyPress and event.modifiers() == QtCore.Qt.ControlModifier:
            if event.key() == QtCore.Qt.Key_Plus:
                self.changeScale(1.1)
                return True
            elif event.key() == QtCore.Qt.Key_Minus:
                self.changeScale(0.9)
                return True
        elif event.type() == QtCore.QEvent.Wheel and event.modifiers() == QtCore.Qt.ControlModifier:
            coefficient = 1.0 + event.delta() / 1440.0
            self.changeScale(coefficient)
        return False

class MainWindow(QtGui.QMainWindow):

    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self.setupFileMenu()
        self.setupCommandsMenu()
        self.setupHelpMenu()

        self.setupEditor()

        self.setCentralWidget(self.mainwidget)
        self.setWindowTitle("fMBT GT editor")

        self._refreshed_gt = ""
        self._refreshed_conf = ""

        self._gtFileName = "noname.gt"
        self._confFileName = "fmbt-gteditor.conf.tmp"
        self._logFileName = None

    def about(self):
        QtGui.QMessageBox.about(self, "fMBT GT editor",
                "<p>The <b>fMBT GT editor</b> demo<br>0.0 alpha")

    def newFile(self):
        self.editor.setPlainText("P(start, \"gt:istate\")\n->\n")
        self.editor.moveCursor(QtGui.QTextCursor.End)
        self._gtFileName = "noname.gt"

    def saveFile(self):
        print "[saving '%s']" % (self._gtFileName,)
        file(self._gtFileName, "w").write(self.editor.toPlainText())

    def saveFileAs(self):
        path = QtGui.QFileDialog.getSaveFileName(self, "Save File",
                                                 '', "fMBT GT files (*.gt)")
        if fallback_to_PyQt4:
            self._gtFileName = str(path)
        else:
            self._gtFileName = path[0]

        if not self._gtFileName:
            self._gtFileName = "noname.gt"
        self.saveFile()

    def openFile(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getOpenFileName(self, "Open File",
                    '', "fMBT GT files (*.gt)")
            if not fallback_to_PyQt4 and path: path = path[0]
        if path:
            self.editor.setPlainText(file(path).read())
            self.conf_editor.setPlainText("")
            self._doGenerateConf()
            self._gtFileName = path

    def runcmd(self, cmd):
        print cmd
        p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        output = p.stdout.read()
        print output
        return p.wait()

    def autoSave(self):
        saved = 0
        gt_contents = self.editor.toPlainText()
        if self._refreshed_gt != gt_contents:
            file(self._gtFileName, "w").write(gt_contents)
            self._refreshed_gt = gt_contents
            saved += 1
        conf_contents = str(self.conf_editor.toPlainText()).strip()
        if self._refreshed_conf != conf_contents:
            if conf_contents == "":
                self._doGenerateConf()
            else:
                file(self._confFileName, "w").write(conf_contents)
            self._refreshed_conf = conf_contents
            saved += 2
        return saved

    def visualiseModel(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        filename = self._gtFileName
        imgname = filename + ".png"
        self._lstsFileName = self._gtFileName + ".gted.lsts.tmp"
        try: file(self._logFileName)
        except: logparam = ""
        else: logparam = "-l '%s'" % (self._logFileName)
        s = self.runcmd("fmbt-gt -o '%s' -f '%s' && fmbt-view -f png %s -o '%s' '%s'" % (self._lstsFileName, filename, logparam, imgname, self._lstsFileName))
        if s != 0:
            print "fmbt-view call returned != 0"
            return
        self.preview_modelimage_pixmap = QtGui.QPixmap()
        self.preview_modelimage_pixmap.load(imgname)
        self.preview_modelimage.setPixmap(self.preview_modelimage_pixmap)
        self.preview_modelcont.area.setWidget(self.preview_modelimage)
        self.preview_modelcont.area.wheel_scale_changed()
        if change_tab:
            self.preview.setCurrentIndex(PREVIEW_MODEL)
            print "display '%s'" % (imgname,)

    def plotDistribution(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        self._distFileName = self._gtFileName + ".gted.dist.png"
        s = self.runcmd("fmbt-stats -f dist:next,sort -p '%s' -o /dev/null '%s'" %
                        (self._distFileName, self._logFileName))
        self.preview_distimage_pixmap = QtGui.QPixmap()
        self.preview_distimage_pixmap.load(self._distFileName)
        self.preview_distimage.setPixmap(self.preview_distimage_pixmap)
        self.preview_distcont.area.setWidget(self.preview_distimage)
        self.preview_distcont.area.wheel_scale_changed()
        if change_tab:
            self.preview.setCurrentIndex(PREVIEW_DIST)
            print "display '%s'" % (self._distFileName,)

    def _doGenerateConf(self):
        filename = self._gtFileName
        self._confFileName = self._gtFileName + ".gted.conf.tmp"
        regenerate = False
        try:
            if file(self._confFileName).read().strip() == "": regenerate=True
        except: regenerate=True
        if regenerate:
            file(self._confFileName, "w").write("""
model="lsts_remote:fmbt-gt -f '%s'"
heuristic="lookahead:4"
coverage="perm:2"
pass="steps:20"
on_pass="exit:0"
on_fail="exit:1"
on_inconc="exit:2"
""" % (self._gtFileName,))
            self.conf_editor.setPlainText(file(self._confFileName).read())

    def _doGenerateTest(self):
        self._doGenerateConf()
        self._logFileName = self._gtFileName + ".gted.log.tmp"
        cmd = "fmbt -l '%s' '%s'" % (self._logFileName, self._confFileName)
        return self.runcmd(cmd)

    def generateTest(self, change_tab = True):
        self.autoSave()
        filename = self._gtFileName
        self._doGenerateTest()
        p = subprocess.Popen("fmbt-log -f '$sn$tv\t$ax$tr' '%s'"
                             % (self._logFileName,), shell=True, stdout=subprocess.PIPE)
        o = p.stdout.read()
        self.preview_test.setPlainText(o)
        if change_tab:
            self.preview.setCurrentIndex(PREVIEW_TEST)

    def editGT(self):
        self.edit.setCurrentIndex(EDIT_GT)

    def editConf(self):
        if str(self.conf_editor.toPlainText()).strip() == "":
            self._doGenerateConf()
            self.conf_editor.setPlainText(file(self._confFileName).read())
        self.edit.setCurrentIndex(EDIT_CONF)

    def setupEditor(self):
        class MyEventFilter(QtCore.QObject):
            def __init__(self, parent):
                QtCore.QObject.__init__(self, parent)
                self.parent = parent
                self.parent._iterate_index = -1
            def eventFilter(self, obj, event):
                if event.type() != QtCore.QEvent.KeyPress: return False
                if event.key() == QtCore.Qt.Key_Tab:
                    self.parent._iterate_index += 1
                    self.parent.completion()
                    return True
                else:
                    self.parent._iterate_index = -1
                return False
        self._eventFilter = MyEventFilter(self)

        self.mainwidget = QtGui.QWidget()
        self.layout = QtGui.QHBoxLayout()
        self.mainwidget.setLayout(self.layout)

        # Setup editor tabs
        self.edit = QtGui.QTabWidget()
        
        def makeScalableEditor(parent, font):
            editor = QtGui.QTextEdit()
            editor.setFont(font)
            editor_scaleevents = MyScaleEvents(editor, editor, 0.1, 2.0)
            editor.wheel_scale = 1.0
            editor.wheel_scale_changed = lambda: (font.setPointSize(editor.wheel_scale * 12.0), editor.setFont(font))
            editor.installEventFilter(editor_scaleevents)
            return editor

        self.editor_font = QtGui.QFont()
        self.editor_font.setFamily('Courier')
        self.editor_font.setFixedPitch(True)
        self.editor_font.setPointSize(12)

        self.editor = makeScalableEditor(self.edit, self.editor_font)
        self.editor_tabevents = MyEventFilter(self)
        self.editor.installEventFilter(self.editor_tabevents)
        self.edit.addTab(self.editor, "GT - F1")

        self.conf_editor = makeScalableEditor(self.edit, self.editor_font)
        self.edit.addTab(self.conf_editor, "Configuration - F2")

        self.highlighter = Highlighter(self.editor.document())
        self.layout.addWidget(self.edit, 1)

        # Setup preview tabs
        self.preview = QtGui.QTabWidget()
        self.layout.addWidget(self.preview, 1)

        def makeScalableImage(parent, image):
            container = QtGui.QWidget(parent)
            layout = QtGui.QHBoxLayout()
            container.setLayout(layout)

            image.setSizePolicy(QtGui.QSizePolicy.Ignored, QtGui.QSizePolicy.Ignored)
            image.setScaledContents(True)
            image.resize(QtCore.QSize(0,0))

            area = QtGui.QScrollArea(container)
            area.setWidget(image)
            area.scale_event_filter = MyScaleEvents(area, area, 0.1, 1.0)
            area.wheel_scale = 1.0
            area.wheel_scale_changed = lambda: image.resize(area.wheel_scale * image.pixmap().size())
            area.installEventFilter(area.scale_event_filter)
            layout.addWidget(area)
            container.area = area # protect from garbage collector
            container.Xlayout = layout # protect from garbage collector
            return container
            
        self.preview_modelimage = QtGui.QLabel(self.preview)
        self.preview_modelcont = makeScalableImage(self.preview, self.preview_modelimage)
        self.preview.addTab(self.preview_modelcont, "Model - F5")
        
        self.preview_test = QtGui.QTextEdit()
        self.preview.addTab(self.preview_test, "Test - F6")

        self.preview_distimage = QtGui.QLabel(self.preview)
        self.preview_distcont = makeScalableImage(self.preview, self.preview_distimage)
        self.preview.addTab(self.preview_distcont, "Distrib - F7")
    
    def setupFileMenu(self):
        fileMenu = QtGui.QMenu("&File", self)
        self.menuBar().addMenu(fileMenu)
        fileMenu.addAction("&New...", self.newFile, "Ctrl+N")
        fileMenu.addAction("&Open...", self.openFile, "Ctrl+O")
        fileMenu.addAction("&Save", self.saveFile, "Ctrl+S")
        fileMenu.addAction("Save &As...", self.saveFileAs)
        fileMenu.addAction("E&xit", QtGui.qApp.quit, "Ctrl+Q")

    def setupCommandsMenu(self):
        commandMenu = QtGui.QMenu("&Commands", self)
        self.menuBar().addMenu(commandMenu)
        commandMenu.addAction("&Edit GT", self.editGT, "F1")
        commandMenu.addAction("Edit Configuration", self.editConf, "F2")
        commandMenu.addAction("&Visualise model", self.visualiseModel, "F5")
        commandMenu.addAction("&Generate test", self.generateTest, "F6")
        commandMenu.addAction("&Test step distribution", self.plotDistribution, "F7")
        commandMenu.addAction("Auto&completion", self.completion, "Tab")

    def setupHelpMenu(self):
        helpMenu = QtGui.QMenu("&Help", self)
        self.menuBar().addMenu(helpMenu)
        helpMenu.addAction("&About", self.about)

    def completion(self):
        tr_re = re.compile("([!]?)T\(\s*([^),]+)\s*,\s*([^\"),]+|\"[^\"]*\")\s*,\s*([^),]+)\s*\)")
        sp_re = re.compile("([!]?)P\(\s*([^),]+)\s*,\s*([^)]+)\s*\)")
        def stateActionTagNames(txt):
            snames, anames, tnames = [], [], []
            for line in txt.split('\n'):
                for (m_neg, m_src, m_act, m_dst) in tr_re.findall(line):
                    snames.append(m_src)
                    snames.append(m_dst)
                    anames.append(m_act)
                for (m_neg, m_state, m_tag) in sp_re.findall(line):
                    snames.append(m_state)
                    tnames.append(m_tag)
            return snames, anames, tnames
        def cursorForReplacingFromStartOfLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()
        if self._iterate_index == 0:
            _, self._anames, self._tnames = stateActionTagNames(pt)
            self._anames = list(set(self._anames))
            self._anames.sort()
            self._tnames = list(set(self._tnames))
            self._tnames.sort()
            states_above, _, _ = stateActionTagNames(pt[:pos])
            states_below, _, _ = stateActionTagNames(pt[pos:])
            states_above.reverse()
            states = states_above[:5] + states_below[:7] + states_above[5:] + states_below[7:]
            unused_states = set(states)
            uniq_states = [s for s in states
                           if s in unused_states and unused_states.remove(s) == None]
            if not uniq_states:
                self._iterate_index = -1
                return
            self._statenames = uniq_states
        curr_line = pt[:pos].split('\n')[-1]
        if curr_line.strip() == "" or (curr_line.strip().startswith("T") and not ',' in curr_line):
            # Guess source state for T(X
            if not self._statenames:
                self._iterate_index = -1
                return
            if "T" in curr_line: prefix = curr_line[:curr_line.index('T')]
            else: prefix = curr_line
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%sT(%s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 2 and ")" not in curr_line[curr_line.rindex(",")+1:]:
            # Guess destination state for T(..., ..., X
            if not self._statenames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 1:
            # Guess action for T(..., X
            if not self._anames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._anames[self._iterate_index % len(self._anames)],))
        elif (curr_line.startswith("P") and not ',' in curr_line):
            # Guess state for P(X
            if not self._statenames:
                self._iterate_index = -1
                return
            c = cursorForReplacingFromStartOfLine()
            c.insertText("P(%s" % (self._statenames[self._iterate_index % len(self._statenames)],))
        elif (curr_line.startswith("P") and curr_line.count(',') == 1 and not ")" in curr_line):
            # Guess tag for P(..., X
            if not self._tnames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._tnames[self._iterate_index % len(self._tnames)]))

    def refreshImages(self):
        if self.autoSave() != 0:
            if self.preview.currentIndex() == PREVIEW_MODEL:
                self.visualiseModel(change_tab = False)
            elif self.preview.currentIndex() == PREVIEW_TEST:
                self.generateTest(change_tab = False)
            elif self.preview.currentIndex() == PREVIEW_DIST:
                self.plotDistribution(change_tab = False)

class Highlighter(QtGui.QSyntaxHighlighter):

    def __init__(self, parent=None):
        super(Highlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\bT\\b", "\\bP\\b", "->"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        usualErrorsFormat = QtGui.QTextCharFormat()
        usualErrorsFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[TP]\(\""),
                usualErrorsFormat))
        

    def highlightBlock(self, text):

        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)


if __name__ == '__main__':
    app = QtGui.QApplication(sys.argv)
    window = MainWindow()
    window.resize(640, 512)
    if len(sys.argv) > 1:
        window.openFile(sys.argv[1])
        
    window.show()

    timer = QtCore.QTimer()
    timer.connect(timer, QtCore.SIGNAL("timeout()"), window.refreshImages)
    timer.start(1000)

    sys.exit(app.exec_())
