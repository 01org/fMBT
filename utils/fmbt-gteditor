#!/usr/bin/env python

#
# fMBT, free Model Based Testing tool
# Copyright (c) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

# This is a demo / prototype of an editor for fmbt-gt files.

"""
fmbt-gteditor - editor for gt, lsts and test configuration files

Usage: fmbt-gteditor [options] [modelfile]

modelfile is the gt or lsts file to be opened in the editor.

Options:
  -h    print this help

  -p, --no-preview
        do not show previews of model or generated tests. Required if
        fMBT tools are not installed.

  -q, --qt-bindings=<Python Qt4 binding library>
        import QtCore and QtGui from the given binding library instead
        of PySide. Example: fmbt-gteditor -q PyQt4.
"""

import sys
import subprocess
import commands
import re
import os
import getopt

def error(msg, exit_status = 1, gui = False):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
    if gui:
        QtGui.QMessageBox.critical(None, "fmbt-gteditor error", msg)
    sys.exit(exit_status)

PREVIEWTAB_MODEL, PREVIEWTAB_TEST, PREVIEWTAB_DIST, PREVIEWTAB_COV = range(4)
EDITTAB_GT, EDITTAB_CONF = range(2)
TR_RE = re.compile("([!]?)T\(\s*([^),]+)\s*,\s*([^\"),]+|\"[^\"]*\")\s*,\s*([^),]+)\s*\)")
SP_RE = re.compile("([!]?)P\(\s*([^),]+)\s*,\s*([^)]+)\s*\)")
CF_RE = re.compile("^(model|adapter|heuristic|coverage|history|((on_)?(pass|fail|inconc)))\s*=\s*\"[^\"]+\"\s*$")

AAL_AALRE     = re.compile('aal\s"[^"]*"\s*{')
AAL_AALREI    = re.compile('{\s*"[^"]*"\s*laa')
AAL_ACTIONRE  = re.compile('action\s"[^{]*"\s*{')
AAL_ACTIONREI = re.compile('{\s*"[^}]*"\s*noitca')
AAL_TAGRE     = re.compile('tag\s"[^{]*"\s*{')
AAL_TAGREI    = re.compile('{\s*"[^"]*"\s*gat')
AAL_GUARDRE   = re.compile('guard()\s*{')
AAL_BODYRE    = re.compile('body()\s*{')
AAL_ADAPTERRE = re.compile('adapter()\s*{')

# Parse command line, see which Python Qt4 bindings to import

opt_hide_preview = False
opt_modelfile    = None
opt_qt_bindings  = "PySide"

opts, remainder = getopt.getopt(
    sys.argv[1:], 'hpq:',
    ["help", "no-preview", "qt-bindings="])

for opt, arg in opts:
    if opt in ["-h", "--help"]:
        print __doc__
        sys.exit(0)
    elif opt in ["-p", "--no-preview"]:
        opt_hide_preview = True
    elif opt in ["-q", "--qt-bindings"]:
        opt_qt_bindings = arg

if remainder: opt_modelfile = remainder[0]

try:
    QtCore = __import__(opt_qt_bindings + ".QtCore", fromlist=["QtCore"])
    QtGui = __import__(opt_qt_bindings + ".QtGui", fromlist=["QtGui"])
    if opt_qt_bindings == "PySide":
        not_using_PySide = False
    else:
        not_using_PySide = True
except Exception, e:
    error('Error importing Qt4 bindings from "%s": %s\nInstall PySide Python bindings for Qt4 or try different -q parameter.' % (opt_qt_bindings, e))


class MyScaleEvents(QtCore.QObject):
    """
    Catch scaling events: Ctrl++, Ctrl+-, Ctrl+wheel. Change
    attrowner's attribute "wheel_scale" accordingly. Finally call
    attrowner's wheel_scale_changed().
    """
    def __init__(self, parent, attrowner, min_scale, max_scale):
        QtCore.QObject.__init__(self, parent)
        self.min_scale = min_scale
        self.max_scale = max_scale
        self.attrowner = attrowner
    def changeScale(self, coefficient):
        self.attrowner.wheel_scale *= coefficient
        if self.attrowner.wheel_scale < self.min_scale: self.attrowner.wheel_scale = self.min_scale
        elif self.attrowner.wheel_scale > self.max_scale: self.attrowner.wheel_scale = self.max_scale
        self.attrowner.wheel_scale_changed()
    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.KeyPress and event.modifiers() == QtCore.Qt.ControlModifier:
            if event.key() == QtCore.Qt.Key_Plus:
                self.changeScale(1.1)
                return True
            elif event.key() == QtCore.Qt.Key_Minus:
                self.changeScale(0.9)
                return True
        elif event.type() == QtCore.QEvent.Wheel and event.modifiers() == QtCore.Qt.ControlModifier:
            coefficient = 1.0 + event.delta() / 1440.0
            self.changeScale(coefficient)
        return False

def asyncRuncmd(cmd, onThreadSuccess=lambda: None,onSuccess=lambda: None, onError=lambda: None):
    class Async(QtCore.QThread):
        def run(self):
            sys.stdout.write(cmd)
            sys.stdout.flush()
            p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = p.stderr.read() + p.stdout.read()
            sys.stdout.write('\n' + output + '\n')
            sys.stdout.flush()
            onThreadSuccess()
            if p.wait() == 0:
                self.emit(QtCore.SIGNAL("success()"))
            else:
                self.emit(QtCore.SIGNAL("error()"))
    def cleanup():
        del asyncRuncmd.running[cmd]
    if cmd in asyncRuncmd.running: return "Command already running"
    async = Async()
    async.connect(async, QtCore.SIGNAL("success()"), onSuccess)
    async.connect(async, QtCore.SIGNAL("error()"), onError)
    async.connect(async, QtCore.SIGNAL("finished()"), cleanup)
    asyncRuncmd.running[cmd] = async # hide from the garbage collector
    async.start()
asyncRuncmd.running = {}

def removeTemporaryFiles(basefilename):
    for tmps in ["lsts", "conf", "states.png", "dist.png", "cov.png",
                 "py", "log", "aal.log"]:
        tmpfilename = basefilename + ".gted-tmp." + tmps
        try: os.remove(tmpfilename)
        except: pass

class MainWindow(QtGui.QMainWindow):

    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self._refreshed_gt = ""
        self._refreshed_conf = ""

        self._gtFileName = "noname.gt"
        self._confFileName = "fmbt-gteditor.conf.tmp"
        self._logFileName = None

        self._model_ok = False
        self._test_ok = False

        self.setupFileMenu()
        self.setupViewMenu()
        self.setupCommandsMenu()
        self.setupHelpMenu()

        self.setupEditor()
        self._set_gtFileName("noname.gt")

        self.setCentralWidget(self.mainwidget)
        self.setWindowTitle("fMBT GT editor")

    def about(self):
        QtGui.QMessageBox.about(self, "fMBT GT editor",'''
<b>fMBT GT-editor</b><br>
for editing GT files and adjusting test generation parameters<br><br>
Keyboard shortcuts:<br>
<table align="left" cellpadding="2">
<tr><td>Editing</td></tr>
<tr><td><i>Tab</i></td><td>Complete/rotate through states and actions in GT editor</td></tr>
<tr><td><i>Ctrl+C</i></td><td>Copy</td></tr>
<tr><td><i>Ctrl+X</i></td><td>Cut</td></tr>
<tr><td><i>Ctrl+V</i></td><td>Paste</td></tr>
<tr><td><i>Ctrl+Z and Y</i></td><td>Undo / Redo</td></tr>
<tr></tr>
<tr><td>Viewing</td></tr>
<tr><td><i>Ctrl++</i></td><td>Zoom in active view</td></tr>
<tr><td><i>Ctrl+-</i></td><td>Zoom out active view</td></tr>
<tr><td><i>Ctrl+wheel</i><td></td>Zoom in/out active view</td></tr>
<tr><td><i>Shift+F4<i></td><td>Grow preview tabs on the right</td></tr>
<tr><td><i>Shift+F5<i></td><td>Grow editor tabs on the left</td></tr>
</table>
''')

    def _set_gtFileName(self, newname):
        removeTemporaryFiles(self._gtFileName)
        self._gtFileName = str(newname)
        self.edit.setTabText(0, os.path.basename(self._gtFileName) + " - F1")
        if self.gthighlighter:
            self.gthighlighter.setDocument(None)
            del self.gthighlighter
        if self._editingGT():
            self.gthighlighter = GTHighlighter(self.editor.document())
        elif self._editingAAL():
            self.gthighlighter = AALHighlighter(self.editor.document())


    def newFile(self, path=None):
        if path and path.endswith(".aal"):
            return self.newFileAAL(path)
        self.editor.setPlainText("P(start, \"gt:istate\")\n->\n")
        self.editor.moveCursor(QtGui.QTextCursor.End)
        self.editor.setFocus()
        if not path:
            self._set_gtFileName("noname.gt")
        else:
            self._set_gtFileName(path)

    def newFileAAL(self, path=None):
        self.editor.setPlainText('aal "" {\n'
                                 '    language: python {}\n'
                                 '    variables { varname1, varname2 }\n'
                                 '    initial_state {\n'
                                 '        varname1 = 42      # comment1\n'
                                 '        varname2 = \'hello\' # comment2\n'
                                 '    }\n'
                                 '    action "iTestStep1()" {\n'
                                 '        guard() { return varname1 == 42 }\n'
                                 '        body()  { varname2 = \'bye\' }\n'
                                 '    }\n'
                                 '}\n')
        self.editor.moveCursor(QtGui.QTextCursor.NextWord)
        self.editor.moveCursor(QtGui.QTextCursor.NextCharacter)
        self.editor.setFocus()
        if not path:
            self._set_gtFileName("noname.py.aal")
        else:
            self._set_gtFileName(path)

    def saveFile(self):
        print "[saving '%s']" % (self._gtFileName,)
        file(self._gtFileName, "w").write(self.editor.toPlainText())

    def saveFileAs(self):
        path = QtGui.QFileDialog.getSaveFileName(self, "Save File",
                                                 '', "fMBT GT commands (*.gt);;fMBT AAL models (*.aal);;State machines (*.lsts)")
        if not_using_PySide:
            self._set_gtFileName(path)
        else:
            self._set_gtFileName(path[0])

        if not self._gtFileName:
            self._set_gtFileName(path[0])
        self.saveFile()

    def openFile(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getOpenFileName(self, "Open File",
                    '', "fMBT GT commands (*.gt);;fMBT AAL models (*.aal);;State machines (*.lsts)")
            if not not_using_PySide and path: path = path[0]
        if path:
            self.editor.setPlainText(file(path).read())
            self.editor.setFocus()
            self.conf_editor.setPlainText("")
            self._doGenerateConf()
            self._set_gtFileName(path)

    def runcmd(self, cmd):
        print cmd
        p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        output = p.stdout.read()
        print output
        return p.wait()

    def _editingLSTS(self):
        return self._gtFileName.endswith(".lsts") or self._gtFileName.endswith(".lts")

    def _editingAAL(self):
        return self._gtFileName.endswith(".aal")

    def _editingGT(self):
        return not self._editingLSTS() and not self._editingAAL()

    def autoSave(self):
        """
        Save unsaved contents, convert gt to lsts if possible.
        Update self._model_ok (false iff conversion fails).
        """
        saved = 0
        gt_contents = self.editor.toPlainText()
        if self._refreshed_gt != gt_contents:
            file(self._gtFileName, "w").write(gt_contents)
            self._refreshed_gt = gt_contents
            saved += 1
            if self._editingAAL(): # validate AAL
                self._aalcFileName = self._gtFileName + ".gted-tmp.py"
                self._lstsFileName = self._gtFileName + ".gted-tmp.lsts"
                aal2py_cmd = "fmbt-aalc -o '%s' %s" % (self._aalcFileName, self._gtFileName)
                executed_program = "fmbt-aalc"
                validation_exitstatus = self.runcmd(aal2py_cmd)
                if validation_exitstatus == 0:
                    py2lsts_cmd = "remote_pyaal -o '%s' '%s'" % (self._lstsFileName, self._aalcFileName)
                    validation_exitstatus = self.runcmd(py2lsts_cmd)

            elif self._editingGT(): # validate GT
                self._lstsFileName = self._gtFileName + ".gted-tmp.lsts"
                gt2lsts_cmd = "fmbt-gt -o '%s' -f '%s'" % (self._lstsFileName, self._gtFileName)
                executed_program = "fmbt-gt"
                validation_exitstatus = self.runcmd(gt2lsts_cmd)

            else: # validate LSTS (missing)
                self._lstsFileName = self._gtFileName
                validation_exitstatus = 0

            if validation_exitstatus == 0:
                self.edit.setTabIcon(0, QtGui.QIcon())
                self._model_ok = True
            elif validation_exitstatus == 127:
                error('Cannot execute "%s". Check your fMBT installation or PATH.' % (executed_program,), gui=1)
            else:
                self.edit.setTabIcon(0, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
                self._model_ok = False
        conf_contents = str(self.conf_editor.toPlainText()).strip()
        if self._refreshed_conf != conf_contents:
            if conf_contents == "":
                self._doGenerateConf()
            else:
                file(self._confFileName, "w").write(conf_contents)
            self._refreshed_conf = conf_contents
            saved += 2
        return saved

    def pixmapLoader(self, previewtab, filename):
        # previewtab is one of 'model', 'dist', 'cov'
        # returns function that can load an image in non-UI thread
        def loader():
            qimage_attr = 'preview_%sqimage' % (previewtab,)
            if not hasattr(self, qimage_attr):
                setattr(self, qimage_attr, QtGui.QImage())
            getattr(self, qimage_attr).load(filename)
        return loader

    def pixmapViewer(self, previewtab):
        # returns function that presents an image in a qlabel
        # must be run in UI thread
        self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_BrowserReload))
        def viewer():
            # for instance, with 'model' this calls:
            # self.preview_modelimage.setPixmap(fromImage(self.preview_modelqimage))
            # self.preview_modelcont.area.setWidget(self.preview_modelimage)
            # self.preview_modelcont.area.wheel_scale_changed()
            # self.preview.setTabIcon(PREVIEWTAB_MODEL, QtGui.QIcon())
            getattr(self, 'preview_%simage' % (previewtab,)).setPixmap(
                QtGui.QPixmap.fromImage(getattr(self, 'preview_%sqimage' % (previewtab,))))
            container = getattr(self, 'preview_%scont' % (previewtab,))
            container.area.setWidget(getattr(self, 'preview_%simage' % (previewtab,)))
            container.area.wheel_scale_changed()
            self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                    QtGui.QIcon())
        return viewer

    def pixmapUnviewable(self, previewtab):
        def errorhandler():
            self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                    QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
        return errorhandler

    def visualiseModel(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        imgname = self._gtFileName + ".gted-tmp.states.png"
        try: file(self._logFileName)
        except: logparam = ""
        else: logparam = "-l '%s'" % (self._logFileName)
        if self._model_ok:
            if not self._test_ok: logparam = ""
            cmd = "fmbt-view -f png %s -o '%s' '%s'" % (logparam, imgname, self._lstsFileName)
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("model", imgname),
                        onSuccess = self.pixmapViewer("model"),
                        onError = self.pixmapUnviewable("model"))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_MODEL)
            self.preview_modelimage.setFocus()
            print "display '%s'" % (imgname,)

    def plotDistribution(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._distFileName = self._gtFileName + ".gted-tmp.dist.png"
            cmd = "fmbt-stats -f dist:next,sort -p '%s' -o /dev/null '%s'" % (
                self._distFileName, self._logFileName)
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("dist", self._distFileName),
                        onSuccess = self.pixmapViewer("dist"),
                        onError = self.pixmapUnviewable("dist"))

        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_DIST)
            self.preview_distimage.setFocus()
            print "display '%s'" % (self._distFileName,)

    def plotCoverage(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._covFileName = self._gtFileName + ".gted-tmp.cov.png"
            cmd = "fmbt-stats -f cov:steps -p '%s' -o /dev/null '%s'" % (
                self._covFileName, self._logFileName)
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("cov", self._covFileName),
                        onSuccess = self.pixmapViewer("cov"),
                        onError = self.pixmapUnviewable("cov"))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_COV)
            self.preview_covimage.setFocus()
            print "display '%s'" % (self._covFileName,)

    def _doGenerateConf(self):
        filename = self._gtFileName
        self._confFileName = self._gtFileName + ".gted-tmp.conf"
        regenerate = False
        try:
            if file(self._confFileName).read().strip() == "": regenerate=True
        except: regenerate=True
        if regenerate:
            if self._editingLSTS():
                modelspec="lsts:%s" % (self._lstsFileName,)
                lookahead = 4
            elif self._editingAAL():
                modelspec="aal_remote:remote_pyaal -l %s.gted-tmp.aal.log '%s'" % (
                    self._gtFileName, self._gtFileName)
                lookahead = 3
            else:
                modelspec="lsts_remote:fmbt-gt -f '%s'" % (self._gtFileName,)
                lookahead = 4
            file(self._confFileName, "w").write("""model     = "%s"
heuristic = "lookahead:%s"
coverage  = "perm:2"
pass      = "steps:20"
on_pass   = "exit:0"
on_fail   = "exit:1"
on_inconc = "exit:2"
""" % (modelspec, lookahead))
            self.conf_editor.setPlainText(file(self._confFileName).read())

    def _doGenerateTest(self):
        self._doGenerateConf()
        if not self._model_ok:
            self._test_ok = False
            return
        self._logFileName = self._gtFileName + ".gted-tmp.log"
        cmd = "fmbt -l '%s' -o 'adapter=\"dummy\"' '%s'" % (self._logFileName, self._confFileName)
        fmbt_exitstatus = self.runcmd(cmd)
        if fmbt_exitstatus == 0:
            self.edit.setTabIcon(1, QtGui.QIcon())
            self._test_ok = True
        elif fmbt_exitstatus == 127:
            error('Cannot execute "fmbt". Check you fMBT installation and PATH.',gui=1)
        else:
            self.edit.setTabIcon(1, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
            self._test_ok = False

    def generateTest(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            p = subprocess.Popen("fmbt-log -f '$sn$tv\t$ax$tr' '%s'"
                             % (self._logFileName,), shell=True, stdout=subprocess.PIPE)
            o = p.stdout.readlines()
            self.preview_test.setPlainText(''.join([l for l in o[1:]]))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_TEST)
            self.preview_test.setFocus()

    def editGT(self):
        self.edit.setCurrentIndex(EDITTAB_GT)
        self.editor.setFocus()

    def editConf(self):
        if str(self.conf_editor.toPlainText()).strip() == "":
            self._doGenerateConf()
            self.conf_editor.setPlainText(file(self._confFileName).read())
        self.edit.setCurrentIndex(EDITTAB_CONF)
        self.conf_editor.setFocus()

    def setupEditor(self):
        class TabCompletionEventFilter(QtCore.QObject):
            def __init__(self, parent):
                QtCore.QObject.__init__(self, parent)
                self.parent = parent
                self.parent._iterate_index = -1
            def eventFilter(self, obj, event):
                if event.type() != QtCore.QEvent.KeyPress: return False
                if event.key() == QtCore.Qt.Key_Tab:
                    self.parent._iterate_index += 1
                    self.parent.completion()
                    return True
                else:
                    self.parent._iterate_index = -1
                return False
        self._eventFilter = TabCompletionEventFilter(self)

        self.mainwidget = QtGui.QWidget()
        self.layout = QtGui.QHBoxLayout()
        self.mainwidget.setLayout(self.layout)

        # Setup editor tabs
        self.edit = QtGui.QTabWidget()
        self.edit.connect(self.edit, QtCore.SIGNAL("currentChanged(int)"),
                          self.editTabChanged)
        
        def makeScalableEditor(parent, font):
            editor = QtGui.QTextEdit()
            editor.setUndoRedoEnabled(True)
            editor.setLineWrapMode(editor.NoWrap)
            editor.setFont(font)
            editor_scaleevents = MyScaleEvents(editor, editor, 0.1, 2.0)
            editor.wheel_scale = 1.0
            editor.wheel_scale_changed = lambda: (font.setPointSize(editor.wheel_scale * 12.0), editor.setFont(font))
            editor.installEventFilter(editor_scaleevents)
            return editor

        self.editor_font = QtGui.QFont()
        self.editor_font.setFamily('Courier')
        self.editor_font.setFixedPitch(True)
        self.editor_font.setPointSize(12)

        self.editor = makeScalableEditor(self.edit, self.editor_font)
        self.editor_tabevents = TabCompletionEventFilter(self)
        self.editor.installEventFilter(self.editor_tabevents)
        self.edit.addTab(self.editor, "GT - F1")

        self.conf_editor = makeScalableEditor(self.edit, self.editor_font)
        self.edit.addTab(self.conf_editor, "Configuration - F2")

        self.gthighlighter = GTHighlighter(self.editor.document())
        self.confhighlighter = ConfHighlighter(self.conf_editor.document())

        self.splitter = QtGui.QSplitter(self.mainwidget)
        self.layout.addWidget(self.splitter,1)
        self.splitter.addWidget(self.edit)

        # Setup preview tabs
        self.preview = QtGui.QTabWidget()
        self.preview.connect(self.preview, QtCore.SIGNAL("currentChanged(int)"),
                             self.previewTabChanged)

        self.splitter.addWidget(self.preview)
        self._editorsOnLeft = True

        def makeScalableImage(parent, image):
            container = QtGui.QWidget(parent)
            layout = QtGui.QHBoxLayout()
            container.setLayout(layout)

            image.setSizePolicy(QtGui.QSizePolicy.Ignored, QtGui.QSizePolicy.Ignored)
            image.setScaledContents(True)
            image.resize(QtCore.QSize(0,0))

            area = QtGui.QScrollArea(container)
            area.setWidget(image)
            area.scale_event_filter = MyScaleEvents(area, area, 0.1, 1.0)
            area.wheel_scale = 1.0
            area.wheel_scale_changed = lambda: image.resize(area.wheel_scale * image.pixmap().size())
            area.installEventFilter(area.scale_event_filter)
            layout.addWidget(area)
            container.area = area
            container._layout = layout # protect from garbage collector
            return container

        self.preview_modelimage = QtGui.QLabel(self.preview)
        self.preview_modelcont = makeScalableImage(self.preview, self.preview_modelimage)
        self.preview.addTab(self.preview_modelcont, "Model - F5")

        self.preview_test = makeScalableEditor(self.preview, self.editor_font)
        self.preview.addTab(self.preview_test, "Test - F6")

        self.preview_distimage = QtGui.QLabel(self.preview)
        self.preview_distcont = makeScalableImage(self.preview, self.preview_distimage)
        self.preview.addTab(self.preview_distcont, "Distrib - F7")

        self.preview_covimage = QtGui.QLabel(self.preview)
        self.preview_covcont = makeScalableImage(self.preview, self.preview_covimage)
        self.preview.addTab(self.preview_covcont, "Coverage - F8")

    def editTabChanged(self, tabIndex):
        if tabIndex == EDITTAB_GT: self.editGT()
        elif tabIndex == EDITTAB_CONF: self.editConf()

    def previewTabChanged(self, tabIndex):
        if tabIndex == PREVIEWTAB_MODEL: self.visualiseModel()
        elif tabIndex == PREVIEWTAB_TEST: self.generateTest()
        elif tabIndex == PREVIEWTAB_DIST: self.plotDistribution()
        elif tabIndex == PREVIEWTAB_COV: self.plotCoverage()

    def setupFileMenu(self):
        fileMenu = QtGui.QMenu("&File", self)
        self.menuBar().addMenu(fileMenu)
        fileMenu.addAction("&New GT", self.newFile, "Ctrl+N")
        fileMenu.addAction("New AA&L", self.newFileAAL)
        fileMenu.addAction("&Open...", self.openFile, "Ctrl+O")
        fileMenu.addAction("&Save", self.saveFile, "Ctrl+S")
        fileMenu.addAction("Save &As...", self.saveFileAs)
        fileMenu.addAction("E&xit", QtGui.qApp.quit, "Ctrl+Q")

    def setupViewMenu(self):
        viewMenu = QtGui.QMenu("&View", self)
        self.menuBar().addMenu(viewMenu)
        viewMenu.addAction("Grow &editors", lambda: self.growTabs(0), "Shift+F5")
        viewMenu.addAction("Grow &previews", lambda: self.growTabs(1), "Shift+F4")
        viewMenu.addAction("Toggle editors on &top/left", self.toggleEditorsLeft, "Ctrl+T")

    def setupCommandsMenu(self):
        commandMenu = QtGui.QMenu("&Commands", self)
        self.menuBar().addMenu(commandMenu)
        commandMenu.addAction("Edit &GT",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_GT),
                                       self.editor.setFocus()),
                              "F1")
        commandMenu.addAction("Edit &Configuration",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_CONF),
                                       self.conf_editor.setFocus()),
                              "F2")
        commandMenu.addAction("&Visualise model",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_MODEL),
                                       self.preview_modelimage.setFocus()),
                              "F5")
        commandMenu.addAction("&Generate test",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_TEST),
                                       self.preview_test.setFocus()),
                              "F6")
        commandMenu.addAction("&Test step distribution",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_DIST),
                                       self.preview_distimage.setFocus()),
                              "F7")
        commandMenu.addAction("C&overage",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_COV),
                                       self.preview_covimage.setFocus()),
                              "F8")

    def setupHelpMenu(self):
        helpMenu = QtGui.QMenu("&Help", self)
        self.menuBar().addMenu(helpMenu)
        helpMenu.addAction("&About", self.about)

    def growTabs(self, grow):
        sizes = self.splitter.sizes()
        totalsizes = sum(sizes)
        sizes[grow] += totalsizes / 8
        sizes[1-grow] = totalsizes - sizes[grow]
        if sizes[1-grow] < totalsizes * .17:
            sizes[grow] += sizes[1-grow]
            sizes[1-grow] = 0
        self.splitter.setSizes(sizes)

    def toggleEditorsLeft(self):
        self._editorsOnLeft = not self._editorsOnLeft
        if self._editorsOnLeft:
            self.splitter.setOrientation(QtCore.Qt.Horizontal)
        else:
            self.splitter.setOrientation(QtCore.Qt.Vertical)

    def completion(self):
        if self._editingGT(): self.completionGT()
        elif self._editingAAL(): self.completionAAL()

    def completionGT(self):
        def stateActionTagNames(txt):
            snames, anames, tnames = [], [], []
            for line in txt.split('\n'):
                for (m_neg, m_src, m_act, m_dst) in TR_RE.findall(line):
                    snames.append(m_src)
                    snames.append(m_dst)
                    anames.append(m_act)
                for (m_neg, m_state, m_tag) in SP_RE.findall(line):
                    snames.append(m_state)
                    tnames.append(m_tag)
            return snames, anames, tnames
        def cursorForReplacingFromStartOfLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()
        if self._iterate_index == 0:
            _, self._anames, self._tnames = stateActionTagNames(pt)
            self._anames = list(set(self._anames))
            self._anames.sort()
            self._tnames = list(set(self._tnames))
            self._tnames.sort()
            states_above, _, _ = stateActionTagNames(pt[:pos])
            states_below, _, _ = stateActionTagNames(pt[pos:])
            states_above.reverse()
            states = states_above[:5] + states_below[:7] + states_above[5:] + states_below[7:]
            unused_states = set(states)
            uniq_states = [s for s in states
                           if s in unused_states and unused_states.remove(s) == None]
            if not uniq_states:
                self._iterate_index = -1
                return
            self._statenames = uniq_states
        curr_line = pt[:pos].split('\n')[-1]
        if curr_line.strip() == "" or (curr_line.strip().startswith("T") and not ',' in curr_line):
            # Guess source state for T(X
            if not self._statenames:
                self._iterate_index = -1
                return
            if "T" in curr_line: prefix = curr_line[:curr_line.index('T')]
            else: prefix = curr_line
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%sT(%s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 2 and ")" not in curr_line[curr_line.rindex(",")+1:]:
            # Guess destination state for T(..., ..., X
            if not self._statenames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 1:
            # Guess action for T(..., X
            if not self._anames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._anames[self._iterate_index % len(self._anames)],))
        elif (curr_line.startswith("P") and not ',' in curr_line):
            # Guess state for P(X
            if not self._statenames:
                self._iterate_index = -1
                return
            c = cursorForReplacingFromStartOfLine()
            c.insertText("P(%s" % (self._statenames[self._iterate_index % len(self._statenames)],))
        elif (curr_line.startswith("P") and curr_line.count(',') == 1 and not ")" in curr_line):
            # Guess tag for P(..., X
            if not self._tnames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._tnames[self._iterate_index % len(self._tnames)]))

    def completionAAL(self):
        def parserishAAL(text, cursor):
            # search for the start of surrounding block
            subblocks = 0
            blockStartsAt = None
            openBraces = 0
            index = cursor
            blockname = None
            while blockStartsAt == None and openBraces > -1 and index > 0:
                openBraces = text.rfind('{', 0, index)
                closeBraces = text.rfind('}', 0, index)
                if openBraces > closeBraces: # found '{'
                    if subblocks == 0: blockStartsAt = openBraces
                    else:
                        subblocks -= 1
                        index = openBraces
                else: # found '}' or neither of {}
                    subblocks += 1
                    index = closeBraces
            if blockStartsAt:
                s = text[:blockStartsAt + 1]
                s = s[::-1] # reverse string
                print s
                for name, regexp in [("aal", AAL_AALREI), ("action", AAL_ACTIONREI), ("tag", AAL_TAGREI)]:
                    m = regexp.match(s)
                    if m:
                        blockname = name
                        print "found", blockname
                        print text[blockStartsAt - m.end():blockStartsAt]
                        index = blockStartsAt - m.end() + 1
                        break
            return blockname, index
        def moveCursor(suggestion):
            for _ in xrange(suggestion[1]):
                self.editor.moveCursor(QtGui.QTextCursor.Up)
            self.editor.moveCursor(QtGui.QTextCursor.EndOfLine)
            for _ in xrange(suggestion[2]):
                self.editor.moveCursor(QtGui.QTextCursor.Left)
        def cursorForReplacingWholeLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.EndOfLine, QtGui.QTextCursor.MoveAnchor)
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        if not hasattr(self, '_iterate_options') or self._iterate_index == 0:
            self._iterate_options = []

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()

        prev_lfeed = pt[:pos].rfind('\n')
        next_lfeed = pt[pos:].find('\n') + pos
        line_contents = pt[prev_lfeed:next_lfeed].strip()
        print "line_contents '%s'" % (line_contents,)
        if self._iterate_index == 0 and line_contents == "":
            self._iterate_options = []
            # Tab completion suggestions for an empty line inside
            # different blocks.
            # block -> [ ("contents", cursor-up, cursor-left), ... ]
            suggestions = {
                'aal': [('action "i" {\n}', 1, 3),
                        ('tag "" {\n    guard() { return }\n}', 2, 3)],
                'action': [('guard() { return }', 0, 1),
                           ('body() {\n    \n}', 1, 0),
                           ('adapter() {\n    \n}', 1, 0)],
                'tag': [('guard() { return }', 0, 1)],
                'guard': [('return ', 0, 0)]
                }

            currentBlock, blockStartIndex = parserishAAL(pt, pos)
            print "currentBlock ==", currentBlock
            if currentBlock in ['aal', 'action', 'tag', 'guard']:
                indentation_depth = blockStartIndex - pt[:blockStartIndex].rfind('\n') + 3
                for suggestion in suggestions[currentBlock]:
                    insert_text = ""
                    for line in suggestion[0].split('\n'):
                        insert_text += (' ' * indentation_depth) + (line + '\n')
                    self._iterate_options.append((insert_text[:-1], suggestion[1], suggestion[2]))
                self._iterate_options += [("", 0, 0)]
        if self._iterate_index == 0:
            # Adjust indentation.
            # If there are block-specific suggestions from above,
            # suggest only one (the most likely) indentation before
            # larger suggestions. Otherwise rotate through all
            # indentations.
            try: prev_line = pt[pt.rfind('\n',0,prev_lfeed-1):prev_lfeed]
            except Exception, e:
                self._iterate_index = -1
                return
            depth = len(prev_line) - len(prev_line.lstrip())
            if prev_line.rstrip()[-1] in ['{', ':']: depth += 4
            if line_contents == '}': depth -= 4
            indentation_options = []
            for d in range(depth)[::4]:
                indentation_options.append(((" " * d) + line_contents, 0, len(line_contents)))
            indentation_options.reverse()
            if not self._iterate_options:
                self._iterate_options = indentation_options
            else:
                self._iterate_options = indentation_options[:1] + self._iterate_options
            for o in self._iterate_options: print "opt: '%s'" % (o,)
        if self._iterate_index > 0:
            # Undo previously added text.
            self.editor.document().undo()
        insert_text = ""
        suggindex = self._iterate_index % len(self._iterate_options)
        insert_text = self._iterate_options[suggindex][0]
        self.editor.textCursor().beginEditBlock()
        c = cursorForReplacingWholeLine()
        c.insertText(insert_text)
        # make sure there is always something to be undone
        c.insertText('x')
        c.deletePreviousChar()
        moveCursor(self._iterate_options[suggindex])
        self.editor.textCursor().endEditBlock()

    def refreshImages(self):
        if self.preview.isVisible() and self.autoSave() != 0:
            if self.preview.currentIndex() == PREVIEWTAB_MODEL:
                self.visualiseModel(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_TEST:
                self.generateTest(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_DIST:
                self.plotDistribution(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_COV:
                self.plotCoverage(change_tab = False)

class GTHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(GTHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\bT\\b", "\\bP\\b", "->"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        usualErrorsFormat = QtGui.QTextCharFormat()
        usualErrorsFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[TP]\(\""),
                usualErrorsFormat))
        self._usualErrorsFormat = usualErrorsFormat

    def highlightBlock(self, text):
        # Before coloring, check if this is a valid line
        text = str(text)
        if not TR_RE.findall(text):
            if not SP_RE.findall(text):
                if not text.startswith("#"):
                    if not text.strip() == "->":
                        self.setFormat(0, len(text), self._usualErrorsFormat)
                        self.setCurrentBlockState(0)
                        return
        
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

class AALHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(AALHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\baal\\b", "\\bvariables\\b", "\\binitial_state\\b", "\\blanguage\\b",
                           "\\baction\\b", "\\btag\\b",
                           "\\bguard\\b", "\\bbody\\b", "\\badapter\\b"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("#[^\n]*"),
                singleLineCommentFormat))

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

class ConfHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(ConfHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["^model\\b", "^adapter\\b", "^heuristic\\b",
                           "^coverage\\b", "^history\\b",
                           "^(on_)?(pass|fail|inconc)\\b"]

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\"[^\"]*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        self._usualErrorsFormat = QtGui.QTextCharFormat()
        self._usualErrorsFormat.setForeground(QtCore.Qt.red)

    def highlightBlock(self, text):
        text = str(text)
        if not CF_RE.match(text):
            if not text.startswith("#"):
                self.setFormat(0, len(text), self._usualErrorsFormat)
                self.setCurrentBlockState(0)
                return
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

if __name__ == '__main__':

    app = QtGui.QApplication(sys.argv)
    window = MainWindow()
    window.resize(640, 512)

    if opt_modelfile:
        if not os.access(opt_modelfile, os.F_OK):
            window.newFile(opt_modelfile)
        elif os.access(opt_modelfile, os.R_OK):
            window.openFile(opt_modelfile)
        else:
            error('cannot open file "%s"' % (opt_modelfile,))

    if opt_hide_preview: window.preview.hide()

    window.show()

    timer = QtCore.QTimer()
    timer.connect(timer, QtCore.SIGNAL("timeout()"), window.refreshImages)
    timer.start(1000)

    app.exec_()
    removeTemporaryFiles(window._gtFileName)
