#!/usr/bin/env python

#
# fMBT, free Model Based Testing tool
# Copyright (c) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

# This is a demo / prototype of an editor for fmbt-gt files.

"""
fmbt-gteditor - editor for gt, lsts and test configuration files

Usage: fmbt-gteditor [options] [modelfile]

modelfile is the gt or lsts file to be opened in the editor.

Options:
  -h    print this help

  -p, --no-preview
        do not show previews of model or generated tests. Required if
        fMBT tools are not installed.

  -q, --qt-bindings=<Python Qt4 binding library>
        import QtCore and QtGui from the given binding library instead
        of PySide. Example: fmbt-gteditor -q PyQt4.
"""

import sys
import subprocess
import commands
import re
import os
import getopt

def error(msg, exit_status = 1, gui = False):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
    if gui:
        QtGui.QMessageBox.critical(None, "fmbt-gteditor error", msg)
    sys.exit(exit_status)

PREVIEWTAB_MODEL, PREVIEWTAB_TEST, PREVIEWTAB_DIST, PREVIEWTAB_COV = range(4)
EDITTAB_GT, EDITTAB_CONF = range(2)
TR_RE = re.compile("([!]?)T\(\s*([^),]+)\s*,\s*([^\"),]+|\"[^\"]*\")\s*,\s*([^),]+)\s*\)")
SP_RE = re.compile("([!]?)P\(\s*([^),]+)\s*,\s*([^)]+)\s*\)")
CF_RE = re.compile("^(model|adapter|heuristic|coverage|history|((on_)?(pass|fail|inconc)))\s*=\s*\"[^\"]+\"\s*$")

# Parse command line, see which Python Qt4 bindings to import

opt_hide_preview = False
opt_modelfile    = None
opt_qt_bindings  = "PySide"

opts, remainder = getopt.getopt(
    sys.argv[1:], 'hpq:',
    ["help", "no-preview", "qt-bindings="])

for opt, arg in opts:
    if opt in ["-h", "--help"]:
        print __doc__
        sys.exit(0)
    elif opt in ["-p", "--no-preview"]:
        opt_hide_preview = True
    elif opt in ["-q", "--qt-bindings"]:
        opt_qt_bindings = arg

if remainder: opt_modelfile = remainder[0]

try:
    QtCore = __import__(opt_qt_bindings + ".QtCore", fromlist=["QtCore"])
    QtGui = __import__(opt_qt_bindings + ".QtGui", fromlist=["QtGui"])
    if opt_qt_bindings == "PySide":
        not_using_PySide = False
    else:
        not_using_PySide = True
except Exception, e:
    error('Error importing Qt4 bindings from "%s": %s\nInstall PySide Python bindings for Qt4 or try different -q parameter.' % (opt_qt_bindings, e))


class MyScaleEvents(QtCore.QObject):
    """
    Catch scaling events: Ctrl++, Ctrl+-, Ctrl+wheel. Change
    attrowner's attribute "wheel_scale" accordingly. Finally call
    attrowner's wheel_scale_changed().
    """
    def __init__(self, parent, attrowner, min_scale, max_scale):
        QtCore.QObject.__init__(self, parent)
        self.min_scale = min_scale
        self.max_scale = max_scale
        self.attrowner = attrowner
    def changeScale(self, coefficient):
        self.attrowner.wheel_scale *= coefficient
        if self.attrowner.wheel_scale < self.min_scale: self.attrowner.wheel_scale = self.min_scale
        elif self.attrowner.wheel_scale > self.max_scale: self.attrowner.wheel_scale = self.max_scale
        self.attrowner.wheel_scale_changed()
    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.KeyPress and event.modifiers() == QtCore.Qt.ControlModifier:
            if event.key() == QtCore.Qt.Key_Plus:
                self.changeScale(1.1)
                return True
            elif event.key() == QtCore.Qt.Key_Minus:
                self.changeScale(0.9)
                return True
        elif event.type() == QtCore.QEvent.Wheel and event.modifiers() == QtCore.Qt.ControlModifier:
            coefficient = 1.0 + event.delta() / 1440.0
            self.changeScale(coefficient)
        return False

class MainWindow(QtGui.QMainWindow):

    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self._refreshed_gt = ""
        self._refreshed_conf = ""

        self._gtFileName = "noname.gt"
        self._confFileName = "fmbt-gteditor.conf.tmp"
        self._logFileName = None

        self._model_ok = False
        self._test_ok = False

        self.setupFileMenu()
        self.setupViewMenu()
        self.setupCommandsMenu()
        self.setupHelpMenu()

        self.setupEditor()

        self.setCentralWidget(self.mainwidget)
        self.setWindowTitle("fMBT GT editor")

    def about(self):
        QtGui.QMessageBox.about(self, "fMBT GT editor",'''
<b>fMBT GT-editor</b><br>
for editing GT files and adjusting test generation parameters<br><br>
Keyboard shortcuts:<br>
<table align="left" cellpadding="2">
<tr><td>Editing</td></tr>
<tr><td><i>Tab</i></td><td>Complete/rotate through states and actions in GT editor</td></tr>
<tr><td><i>Ctrl + C</i></td><td>Copy</td></tr>
<tr><td><i>Ctrl + X</i></td><td>Cut</td></tr>
<tr><td><i>Ctrl + V</i></td><td>Paste</td></tr>
<tr><td><i>Ctrl + Z and Y</i></td><td>Undo / Redo</td></tr>
<tr></tr>
<tr><td>Viewing</td></tr>
<tr><td><i>Ctrl + +</i></td><td>Zoom in active view</td></tr>
<tr><td><i>Ctrl + -</i></td><td>Zoom out active view</td></tr>
<tr><td><i>Ctrl + wheel</i><td></td>Zoom in/out active view</td></tr>
<tr><td><i>Shift + F4<i></td><td>Grow preview tabs on the right</td></tr>
<tr><td><i>Shift + F5<i></td><td>Grow editor tabs on the left</td></tr>
</table>
''')

    def newFile(self, path=None):
        self.editor.setPlainText("P(start, \"gt:istate\")\n->\n")
        self.editor.moveCursor(QtGui.QTextCursor.End)
        self.editor.setFocus()
        if not path:
            self._gtFileName = "noname.gt"
        else:
            self._gtFileName = path

    def saveFile(self):
        print "[saving '%s']" % (self._gtFileName,)
        file(self._gtFileName, "w").write(self.editor.toPlainText())

    def saveFileAs(self):
        path = QtGui.QFileDialog.getSaveFileName(self, "Save File",
                                                 '', "fMBT GT commands (*.gt);;State machines (*.lsts)")
        if not_using_PySide:
            self._gtFileName = str(path)
        else:
            self._gtFileName = str(path[0])

        if not self._gtFileName:
            self._gtFileName = "noname.gt"
        self.saveFile()

    def openFile(self, path=None):
        if not path:
            path = QtGui.QFileDialog.getOpenFileName(self, "Open File",
                    '', "fMBT GT commands (*.gt);;State machines (*.lsts)")
            if not not_using_PySide and path: path = path[0]
        if path:
            self.editor.setPlainText(file(path).read())
            self.editor.setFocus()
            self.conf_editor.setPlainText("")
            self._doGenerateConf()
            self._gtFileName = str(path)

    def runcmd(self, cmd):
        print cmd
        p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        output = p.stdout.read()
        print output
        return p.wait()

    def _editingLSTS(self):
        return self._gtFileName.endswith(".lsts") or self._gtFileName.endswith(".lts")

    def autoSave(self):
        """
        Save unsaved contents, convert gt to lsts if possible.
        Update self._model_ok (false iff conversion fails).
        """
        saved = 0
        gt_contents = self.editor.toPlainText()
        if self._refreshed_gt != gt_contents:
            file(self._gtFileName, "w").write(gt_contents)
            self._refreshed_gt = gt_contents
            saved += 1
            if not self._editingLSTS():
                self._lstsFileName = self._gtFileName + ".gted.lsts.tmp"
                gt2lsts_cmd = "fmbt-gt -o '%s' -f '%s'" % (self._lstsFileName, self._gtFileName)
                fmbt_gt_exitstatus = self.runcmd(gt2lsts_cmd)
                if fmbt_gt_exitstatus == 0:
                    self.edit.setTabIcon(0, QtGui.QIcon())
                    self._model_ok = True
                elif fmbt_gt_exitstatus == 127:
                    error('Cannot execute "fmbt-gt". Check your fMBT installation or PATH.', gui=1)
                else:
                    self.edit.setTabIcon(0, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
                    self._model_ok = False
            else:
                # LSTS model validation missing
                self._lstsFileName = self._gtFileName
                self._model_ok = True
        conf_contents = str(self.conf_editor.toPlainText()).strip()
        if self._refreshed_conf != conf_contents:
            if conf_contents == "":
                self._doGenerateConf()
            else:
                file(self._confFileName, "w").write(conf_contents)
            self._refreshed_conf = conf_contents
            saved += 2
        return saved

    def visualiseModel(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        imgname = self._gtFileName + ".png"
        try: file(self._logFileName)
        except: logparam = ""
        else: logparam = "-l '%s'" % (self._logFileName)
        if self._model_ok and self._test_ok:
            s = self.runcmd("fmbt-view -f png %s -o '%s' '%s'" % (logparam, imgname, self._lstsFileName))
            if s != 0:
                print "fmbt-view call returned != 0"
                return
            self.preview_modelimage_pixmap = QtGui.QPixmap()
            self.preview_modelimage_pixmap.load(imgname)
            self.preview_modelimage.setPixmap(self.preview_modelimage_pixmap)
            self.preview_modelcont.area.setWidget(self.preview_modelimage)
            self.preview_modelcont.area.wheel_scale_changed()
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_MODEL)
            self.preview_modelimage.setFocus()
            print "display '%s'" % (imgname,)

    def plotDistribution(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._distFileName = self._gtFileName + ".gted.dist.png"
            s = self.runcmd("fmbt-stats -f dist:next,sort -p '%s' -o /dev/null '%s'" %
                            (self._distFileName, self._logFileName))
            self.preview_distimage_pixmap = QtGui.QPixmap()
            self.preview_distimage_pixmap.load(self._distFileName)
            self.preview_distimage.setPixmap(self.preview_distimage_pixmap)
            self.preview_distcont.area.setWidget(self.preview_distimage)
            self.preview_distcont.area.wheel_scale_changed()
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_DIST)
            self.preview_distimage.setFocus()
            print "display '%s'" % (self._distFileName,)

    def plotCoverage(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._covFileName = self._gtFileName + ".gted.cov.png"
            s = self.runcmd("fmbt-stats -f cov:steps -p '%s' -o /dev/null '%s'" %
                            (self._covFileName, self._logFileName))
            self.preview_covimage_pixmap = QtGui.QPixmap()
            self.preview_covimage_pixmap.load(self._covFileName)
            self.preview_covimage.setPixmap(self.preview_covimage_pixmap)
            self.preview_covcont.area.setWidget(self.preview_covimage)
            self.preview_covcont.area.wheel_scale_changed()
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_COV)
            self.preview_covimage.setFocus()
            print "display '%s'" % (self._covFileName,)

    def _doGenerateConf(self):
        filename = self._gtFileName
        self._confFileName = self._gtFileName + ".gted.conf.tmp"
        regenerate = False
        try:
            if file(self._confFileName).read().strip() == "": regenerate=True
        except: regenerate=True
        if regenerate:
            if self._editingLSTS():
                modelspec="lsts:%s" % (self._lstsFileName,)
            else:
                modelspec="lsts_remote:fmbt-gt -f '%s'" % (self._gtFileName,)
            file(self._confFileName, "w").write("""model     = "%s"
heuristic = "lookahead:4"
coverage  = "perm:2"
pass      = "steps:20"
on_pass   = "exit:0"
on_fail   = "exit:1"
on_inconc = "exit:2"
""" % (modelspec,))
            self.conf_editor.setPlainText(file(self._confFileName).read())

    def _doGenerateTest(self):
        self._doGenerateConf()
        if not self._model_ok:
            self._test_ok = False
            return
        self._logFileName = self._gtFileName + ".gted.log.tmp"
        cmd = "fmbt -l '%s' '%s'" % (self._logFileName, self._confFileName)
        fmbt_exitstatus = self.runcmd(cmd)
        if fmbt_exitstatus == 0:
            self.edit.setTabIcon(1, QtGui.QIcon())
            self._test_ok = True
        elif fmbt_exitstatus == 127:
            error('Cannot execute "fmbt". Check you fMBT installation and PATH.',gui=1)
        else:
            self.edit.setTabIcon(1, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
            self._test_ok = False

    def generateTest(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            p = subprocess.Popen("fmbt-log -f '$sn$tv\t$ax$tr' '%s'"
                             % (self._logFileName,), shell=True, stdout=subprocess.PIPE)
            o = p.stdout.readlines()
            self.preview_test.setPlainText(''.join([l for l in o[1:]]))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_TEST)
            self.preview_test.setFocus()

    def editGT(self):
        self.edit.setCurrentIndex(EDITTAB_GT)
        self.editor.setFocus()

    def editConf(self):
        if str(self.conf_editor.toPlainText()).strip() == "":
            self._doGenerateConf()
            self.conf_editor.setPlainText(file(self._confFileName).read())
        self.edit.setCurrentIndex(EDITTAB_CONF)
        self.conf_editor.setFocus()

    def setupEditor(self):
        class MyEventFilter(QtCore.QObject):
            def __init__(self, parent):
                QtCore.QObject.__init__(self, parent)
                self.parent = parent
                self.parent._iterate_index = -1
            def eventFilter(self, obj, event):
                if event.type() != QtCore.QEvent.KeyPress: return False
                if event.key() == QtCore.Qt.Key_Tab:
                    self.parent._iterate_index += 1
                    self.parent.completion()
                    return True
                else:
                    self.parent._iterate_index = -1
                return False
        self._eventFilter = MyEventFilter(self)

        self.mainwidget = QtGui.QWidget()
        self.layout = QtGui.QHBoxLayout()
        self.mainwidget.setLayout(self.layout)

        # Setup editor tabs
        self.edit = QtGui.QTabWidget()
        self.edit.connect(self.edit, QtCore.SIGNAL("currentChanged(int)"),
                          self.editTabChanged)
        
        def makeScalableEditor(parent, font):
            editor = QtGui.QTextEdit()
            editor.setUndoRedoEnabled(True)
            editor.setLineWrapMode(editor.NoWrap)
            editor.setFont(font)
            editor_scaleevents = MyScaleEvents(editor, editor, 0.1, 2.0)
            editor.wheel_scale = 1.0
            editor.wheel_scale_changed = lambda: (font.setPointSize(editor.wheel_scale * 12.0), editor.setFont(font))
            editor.installEventFilter(editor_scaleevents)
            return editor

        self.editor_font = QtGui.QFont()
        self.editor_font.setFamily('Courier')
        self.editor_font.setFixedPitch(True)
        self.editor_font.setPointSize(12)

        self.editor = makeScalableEditor(self.edit, self.editor_font)
        self.editor_tabevents = MyEventFilter(self)
        self.editor.installEventFilter(self.editor_tabevents)
        self.edit.addTab(self.editor, "GT - F1")

        self.conf_editor = makeScalableEditor(self.edit, self.editor_font)
        self.edit.addTab(self.conf_editor, "Configuration - F2")

        self.gthighlighter = GTHighlighter(self.editor.document())
        self.confhighlighter = ConfHighlighter(self.conf_editor.document())
        self.layout.addWidget(self.edit, 1)

        # Setup preview tabs
        self.preview = QtGui.QTabWidget()
        self.preview.connect(self.preview, QtCore.SIGNAL("currentChanged(int)"),
                             self.previewTabChanged)

        self.layout.addWidget(self.preview, 1)

        def makeScalableImage(parent, image):
            container = QtGui.QWidget(parent)
            layout = QtGui.QHBoxLayout()
            container.setLayout(layout)

            image.setSizePolicy(QtGui.QSizePolicy.Ignored, QtGui.QSizePolicy.Ignored)
            image.setScaledContents(True)
            image.resize(QtCore.QSize(0,0))

            area = QtGui.QScrollArea(container)
            area.setWidget(image)
            area.scale_event_filter = MyScaleEvents(area, area, 0.1, 1.0)
            area.wheel_scale = 1.0
            area.wheel_scale_changed = lambda: image.resize(area.wheel_scale * image.pixmap().size())
            area.installEventFilter(area.scale_event_filter)
            layout.addWidget(area)
            container.area = area
            container._layout = layout # protect from garbage collector
            return container

        self.preview_modelimage = QtGui.QLabel(self.preview)
        self.preview_modelcont = makeScalableImage(self.preview, self.preview_modelimage)
        self.preview.addTab(self.preview_modelcont, "Model - F5")

        self.preview_test = makeScalableEditor(self.preview, self.editor_font)
        self.preview.addTab(self.preview_test, "Test - F6")

        self.preview_distimage = QtGui.QLabel(self.preview)
        self.preview_distcont = makeScalableImage(self.preview, self.preview_distimage)
        self.preview.addTab(self.preview_distcont, "Distrib - F7")

        self.preview_covimage = QtGui.QLabel(self.preview)
        self.preview_covcont = makeScalableImage(self.preview, self.preview_covimage)
        self.preview.addTab(self.preview_covcont, "Coverage - F8")

    def editTabChanged(self, tabIndex):
        if tabIndex == EDITTAB_GT: self.editGT()
        elif tabIndex == EDITTAB_CONF: self.editConf()

    def previewTabChanged(self, tabIndex):
        if tabIndex == PREVIEWTAB_MODEL: self.visualiseModel()
        elif tabIndex == PREVIEWTAB_TEST: self.generateTest()
        elif tabIndex == PREVIEWTAB_DIST: self.plotDistribution()
        elif tabIndex == PREVIEWTAB_COV: self.plotCoverage()

    def setupFileMenu(self):
        fileMenu = QtGui.QMenu("&File", self)
        self.menuBar().addMenu(fileMenu)
        fileMenu.addAction("&New...", self.newFile, "Ctrl+N")
        fileMenu.addAction("&Open...", self.openFile, "Ctrl+O")
        fileMenu.addAction("&Save", self.saveFile, "Ctrl+S")
        fileMenu.addAction("Save &As...", self.saveFileAs)
        fileMenu.addAction("E&xit", QtGui.qApp.quit, "Ctrl+Q")

    def setupViewMenu(self):
        viewMenu = QtGui.QMenu("&View", self)
        self.menuBar().addMenu(viewMenu)
        viewMenu.addAction("Grow &editors", lambda: self.growTabs(0), "Shift+F5")
        viewMenu.addAction("Grow &previews", lambda: self.growTabs(1), "Shift+F4")

    def setupCommandsMenu(self):
        commandMenu = QtGui.QMenu("&Commands", self)
        self.menuBar().addMenu(commandMenu)
        commandMenu.addAction("Edit &GT",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_GT),
                                       self.editor.setFocus()),
                              "F1")
        commandMenu.addAction("Edit &Configuration",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_CONF),
                                       self.conf_editor.setFocus()),
                              "F2")
        commandMenu.addAction("&Visualise model",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_MODEL),
                                       self.preview_modelimage.setFocus()),
                              "F5")
        commandMenu.addAction("&Generate test",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_TEST),
                                       self.preview_test.setFocus()),
                              "F6")
        commandMenu.addAction("&Test step distribution",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_DIST),
                                       self.preview_distimage.setFocus()),
                              "F7")
        commandMenu.addAction("C&overage",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_COV),
                                       self.preview_covimage.setFocus()),
                              "F8")

    def setupHelpMenu(self):
        helpMenu = QtGui.QMenu("&Help", self)
        self.menuBar().addMenu(helpMenu)
        helpMenu.addAction("&About", self.about)

    def growTabs(self, grow):
        layout = self.mainwidget.layout()
        widgets = [self.edit, self.preview]
        if widgets[grow].isVisible() == False:
            widgets[grow].show()
            if grow == 1: self.refreshImages()
        elif layout.stretch(1-grow) > 1:
            layout.setStretch(1-grow, layout.stretch(1-grow)/2)
        elif layout.stretch(grow) < 8:
            layout.setStretch(grow, layout.stretch(grow) * 2)
        else:
            widgets[1-grow].hide()

    def completion(self):
        def stateActionTagNames(txt):
            snames, anames, tnames = [], [], []
            for line in txt.split('\n'):
                for (m_neg, m_src, m_act, m_dst) in TR_RE.findall(line):
                    snames.append(m_src)
                    snames.append(m_dst)
                    anames.append(m_act)
                for (m_neg, m_state, m_tag) in SP_RE.findall(line):
                    snames.append(m_state)
                    tnames.append(m_tag)
            return snames, anames, tnames
        def cursorForReplacingFromStartOfLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()
        if self._iterate_index == 0:
            _, self._anames, self._tnames = stateActionTagNames(pt)
            self._anames = list(set(self._anames))
            self._anames.sort()
            self._tnames = list(set(self._tnames))
            self._tnames.sort()
            states_above, _, _ = stateActionTagNames(pt[:pos])
            states_below, _, _ = stateActionTagNames(pt[pos:])
            states_above.reverse()
            states = states_above[:5] + states_below[:7] + states_above[5:] + states_below[7:]
            unused_states = set(states)
            uniq_states = [s for s in states
                           if s in unused_states and unused_states.remove(s) == None]
            if not uniq_states:
                self._iterate_index = -1
                return
            self._statenames = uniq_states
        curr_line = pt[:pos].split('\n')[-1]
        if curr_line.strip() == "" or (curr_line.strip().startswith("T") and not ',' in curr_line):
            # Guess source state for T(X
            if not self._statenames:
                self._iterate_index = -1
                return
            if "T" in curr_line: prefix = curr_line[:curr_line.index('T')]
            else: prefix = curr_line
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%sT(%s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 2 and ")" not in curr_line[curr_line.rindex(",")+1:]:
            # Guess destination state for T(..., ..., X
            if not self._statenames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 1:
            # Guess action for T(..., X
            if not self._anames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._anames[self._iterate_index % len(self._anames)],))
        elif (curr_line.startswith("P") and not ',' in curr_line):
            # Guess state for P(X
            if not self._statenames:
                self._iterate_index = -1
                return
            c = cursorForReplacingFromStartOfLine()
            c.insertText("P(%s" % (self._statenames[self._iterate_index % len(self._statenames)],))
        elif (curr_line.startswith("P") and curr_line.count(',') == 1 and not ")" in curr_line):
            # Guess tag for P(..., X
            if not self._tnames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._tnames[self._iterate_index % len(self._tnames)]))

    def refreshImages(self):
        if self.preview.isVisible() and self.autoSave() != 0:
            if self.preview.currentIndex() == PREVIEWTAB_MODEL:
                self.visualiseModel(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_TEST:
                self.generateTest(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_DIST:
                self.plotDistribution(change_tab = False)
            elif self.preview.currentIndex() == PREVIEWTAB_COV:
                self.plotCoverage(change_tab = False)

class GTHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(GTHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\bT\\b", "\\bP\\b", "->"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        usualErrorsFormat = QtGui.QTextCharFormat()
        usualErrorsFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[TP]\(\""),
                usualErrorsFormat))
        self._usualErrorsFormat = usualErrorsFormat

    def highlightBlock(self, text):
        # Before coloring, check if this is a valid line
        text = str(text)
        if not TR_RE.findall(text):
            if not SP_RE.findall(text):
                if not text.startswith("#"):
                    if not text.strip() == "->":
                        self.setFormat(0, len(text), self._usualErrorsFormat)
                        self.setCurrentBlockState(0)
                        return
        
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

class ConfHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(ConfHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["^model\\b", "^adapter\\b", "^heuristic\\b",
                           "^coverage\\b", "^history\\b",
                           "^(on_)?(pass|fail|inconc)\\b"]

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        self._usualErrorsFormat = QtGui.QTextCharFormat()
        self._usualErrorsFormat.setForeground(QtCore.Qt.red)

    def highlightBlock(self, text):
        text = str(text)
        if not CF_RE.match(text):
            if not text.startswith("#"):
                self.setFormat(0, len(text), self._usualErrorsFormat)
                self.setCurrentBlockState(0)
                return
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

if __name__ == '__main__':

    app = QtGui.QApplication(sys.argv)
    window = MainWindow()
    window.resize(640, 512)

    if opt_modelfile:
        if not os.access(opt_modelfile, os.F_OK):
            window.newFile(opt_modelfile)
        elif os.access(opt_modelfile, os.R_OK):
            window.openFile(opt_modelfile)
        else:
            error('cannot open file "%s"' % (opt_modelfile,))

    if opt_hide_preview: window.preview.hide()

    window.show()

    timer = QtCore.QTimer()
    timer.connect(timer, QtCore.SIGNAL("timeout()"), window.refreshImages)
    timer.start(1000)

    sys.exit(app.exec_())
