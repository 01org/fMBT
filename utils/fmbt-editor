#!/usr/bin/env python

#
# fMBT, free Model Based Testing tool
# Copyright (c) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""
fmbt-editor - editor for gt, aal, lsts and test configuration files

Usage: fmbt-editor [options] [model [configuration]]

model is a *.gt, *.aal or *.lsts file to be opened in the editor.
configuration is a *.conf file to be opened in the test configuration
view.

Options:
  -h    print this help

  -p, --no-preview
        do not show previews of model or generated tests. Required if
        fMBT tools are not installed.

  -q, --qt-bindings=<Python Qt4 binding library>
        import QtCore and QtGui from the given binding library instead
        of PySide. Example: fmbt-editor -q PyQt4.

  -Q, --qt=arg
        pass given argument to QApplication. Example:
        fmbt-editor -Q-geometry -Q800x600
"""

import sys
import subprocess
import commands
import re
import os
import getopt
import time
import urllib
import fmbt_config

def error(msg, exit_status = 1, gui = False):
    sys.stderr.write("%s: %s\n" % (sys.argv[0], msg))
    if gui:
        QtGui.QMessageBox.critical(None, "fmbt-editor error", msg)
    sys.exit(exit_status)

PREVIEWTAB_MODEL, PREVIEWTAB_TEST, PREVIEWTAB_DIST, PREVIEWTAB_COV, PREVIEWTAB_ERR = range(5)
EDITTAB_GT, EDITTAB_CONF = range(2)

FORMAT_EDITTAB = "%s:%s - F%s"

TR_RE = re.compile("([!]?)T\(\s*([^),]+)\s*,\s*([^\"),]+|\"[^\"]*\")\s*,\s*([^),]+)\s*\)")
SP_RE = re.compile("([!]?)P\(\s*([^),]+)\s*,\s*([^)]+)\s*\)")
CF_RE = re.compile("^(model|adapter|heuristic|coverage|history|((on_)?(pass|fail|inconc)))\s*=\s*\"[^\"]+\"\s*$")

AAL_AALRE     = re.compile('aal\s"[^"]*"\s*{')
AAL_AALREI    = re.compile('{\s*"[^"]*"\s*laa')
AAL_ACTIONRE  = re.compile('action\s"[^{]*"\s*{')
AAL_ACTIONREI = re.compile('{\s*"[^}]*"\s*noitca')
AAL_TAGRE     = re.compile('tag\s"[^{]*"\s*{')
AAL_TAGREI    = re.compile('{\s*"[^"]*"\s*gat')
AAL_GUARDRE   = re.compile('guard()\s*{')
AAL_BODYRE    = re.compile('body()\s*{')
AAL_ADAPTERRE = re.compile('adapter()\s*{')

GT_HIDESHOWRE = re.compile(' preview-(show|hide)-(vars|variables):(.*)')
GT_HIDESHOWTRANRE = re.compile(' preview-(show|hide)-(trans|transitions):(.*)')
GT_HIDEUNTRAVTRANRE = re.compile(' preview-hide-untested-(trans|transitions):(.*)')
GT_SHOWTRAVTRANRE = re.compile(' preview-show-tested-(trans|transitions):(.*)')
GT_HIDESTATES = re.compile(' preview-hide-states:((unvisited)|(orphaned)|,| )*')

GT_DEPTHRE = re.compile(' preview-depth:(.*)')

def isModelFile(filename):
    if filename.lower().endswith(".conf"):
        return False
    elif (filename.lower().endswith(".aal") or
          filename.lower().endswith(".gt") or
          filename.lower().endswith(".lsts")):
        return True
    return True

# Parse command line, see which Python Qt4 bindings to import

opt_hide_preview = False
opt_modelfile    = None
opt_conffile     = None
opt_qt_bindings  = "PySide"
opt_qt           = []

opts, remainder = getopt.getopt(
    sys.argv[1:], 'Vhpq:Q:',
    ["version", "help", "no-preview", "qt-bindings=", "qt="])

for opt, arg in opts:
    if opt in ["-h", "--help"]:
        print __doc__
        sys.exit(0)
    elif opt in ['-V', '--version']:
        print "Version " + fmbt_config.fmbt_version
        sys.exit(0)
    elif opt in ["-p", "--no-preview"]:
        opt_hide_preview = True
    elif opt in ["-q", "--qt-bindings"]:
        opt_qt_bindings = arg
    elif opt in ["-Q", "--qt"]:
        opt_qt.append(arg)

for filename in remainder:
    if filename.lower().endswith(".conf") and opt_conffile == None:
        opt_conffile = filename
    elif (filename.lower().endswith(".aal") or
          filename.lower().endswith(".gt") or
          filename.lower().endswith(".lsts")) and opt_modelfile == None:
        opt_modelfile = filename
    else:
        print __doc__
        sys.stdout.flush()
        error('unexpected parameter: "%s"' % (filename,))

try:
    QtCore = __import__(opt_qt_bindings + ".QtCore", fromlist=["QtCore"])
    QtGui = __import__(opt_qt_bindings + ".QtGui", fromlist=["QtGui"])
    if opt_qt_bindings == "PySide":
        not_using_PySide = False
    else:
        not_using_PySide = True
except Exception, e:
    error('Error importing Qt4 bindings from "%s": %s\nInstall PySide Python bindings for Qt4 or try different -q parameter.' % (opt_qt_bindings, e))

def _deleteTrailingWhitespace(multilineString):
    return '\n'.join([line.rstrip() for line in str(multilineString).split('\n')])

class MyScaleEvents(QtCore.QObject):
    """
    Catch scaling events: Ctrl++, Ctrl+-, Ctrl+wheel. Change
    attrowner's attribute "wheel_scale" accordingly. Finally call
    attrowner's wheel_scale_changed().
    """
    def __init__(self, parent, attrowner, min_scale, max_scale):
        QtCore.QObject.__init__(self, parent)
        self.min_scale = min_scale
        self.max_scale = max_scale
        self.attrowner = attrowner
    def changeScale(self, coefficient):
        self.attrowner.wheel_scale *= coefficient
        if self.attrowner.wheel_scale < self.min_scale: self.attrowner.wheel_scale = self.min_scale
        elif self.attrowner.wheel_scale > self.max_scale: self.attrowner.wheel_scale = self.max_scale
        self.attrowner.wheel_scale_changed()
    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.Wheel and event.modifiers() == QtCore.Qt.ControlModifier:
            coefficient = 1.0 + event.delta() / 1440.0
            self.changeScale(coefficient)
        return False

def asyncRuncmd(cmd, onThreadSuccess=lambda: None, onSuccess=lambda: None, onError=lambda: None):
    """
    Runs cmd (a shell command or Python function) in a separate,
    non-UI thread. onThreadSuccess function is called in the non-UI
    thread, onSuccess and onError functions in the main
    thread. Successful executions are commands with exit status 0 and
    function calls that do not raise exceptions."""
    class Async(QtCore.QThread):
        def run(self):
            if type(cmd) == str or type(cmd) == tuple:
                if type(cmd) == str:
                    useShell = True
                    sys.stdout.write(cmd)
                else:
                    useShell = False
                    sys.stdout.write("%s '%s'" % (cmd[0], "' '".join(cmd[1:])))
                sys.stdout.flush()
                p = subprocess.Popen(cmd, shell=useShell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                output = p.stderr.read() + p.stdout.read()
                sys.stdout.write('\n' + output + '\n')
                sys.stdout.flush()
                if p.wait() == 0:
                    onThreadSuccess()
                    self.emit(Async.signal_success)
                else:
                    self.emit(Async.signal_error)
            else:
                errors = 0
                try: cmd()
                except: errors = 1
                if errors == 0:
                    onThreadSuccess()
                    self.emit(Async.signal_success)
                else:
                    self.emit(Async.signal_error)
        signal_success = QtCore.SIGNAL("success()")
        signal_error = QtCore.SIGNAL("error()")
        signal_finished = QtCore.SIGNAL("finished()")

    def cleanup():
        # At the time of calling cleanup, onSuccess and onError
        # functions might still be needed. Store them to "finished" in
        # order to avoid the garbage collector releasing the memory
        # too early.
        asyncRuncmd.finished[cmd] = asyncRuncmd.running[cmd]
        del asyncRuncmd.running[cmd]
    if type(cmd) == list: cmd = tuple(cmd)
    if cmd in asyncRuncmd.running: return "Command already running"
    async = Async()
    async.connect(async, Async.signal_success, onSuccess, QtCore.Qt.QueuedConnection)
    async.connect(async, Async.signal_error, onError, QtCore.Qt.QueuedConnection)
    async.connect(async, Async.signal_finished, cleanup, QtCore.Qt.QueuedConnection)
    asyncRuncmd.running[cmd] = async # (async, onSuccess, onError, onThreadSuccess, cleanup) # hide from the garbage collector
    async.start()
asyncRuncmd.running = {}
asyncRuncmd.finished = {}

def removeTemporaryFiles(basefilename):
    for tmps in ["lsts", "conf", "states.png", "dist.png", "cov.png",
                 "py", "log", "aal.log"]:
        tmpfilename = basefilename + ".gted-%stmp." % (os.getpid(),) + tmps
        try: os.remove(tmpfilename)
        except: pass

class MainWindow(QtGui.QMainWindow):

    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self._refreshed_gt = ""
        self._refreshed_conf = ""

        self._modelFileName = "noname.gt"
        self._confFileName = None
        self._logFileName = None

        self._model_ok = False
        self._test_ok = False

        self.setupFileMenu()
        self.setupEditMenu()
        self.setupViewMenu()
        self.setupCommandsMenu()
        self.setupHelpMenu()

        self.setupEditor()
        self._set_modelFileName("noname.gt")

        self.setCentralWidget(self.mainwidget)
        self.setWindowTitle("fMBT editor")

        self._last_keypress = time.time() - 10

        self._fileDialogDirectory = None
        self._fileDialogFilter = None
        self._previewTabBeforeError = None
        self._previewTakeFocusOnTabChange = True

    def about(self):
        QtGui.QMessageBox.about(self, "fMBT editor",'''
<b>fMBT editor</b><br>
for editing GT and AAL models and adjusting test generation parameters<br><br>
Keyboard shortcuts:<br>
<table align="left" cellpadding="2">
<tr><td>Editing</td></tr>
<tr><td><i>Ctrl+S</i></td><td>Save (and update previews)</td></tr>
<tr><td><i>Tab</i></td><td>Rotate through completions when editing GT or AAL</td></tr>
<tr><td><i>Ctrl+C</i></td><td>Copy</td></tr>
<tr><td><i>Ctrl+X</i></td><td>Cut</td></tr>
<tr><td><i>Ctrl+V</i></td><td>Paste</td></tr>
<tr><td><i>Ctrl+Z and Y</i></td><td>Undo / Redo</td></tr>
<tr></tr>
<tr><td>Viewing</td></tr>
<tr><td><i>Ctrl++</i></td><td>Zoom in active view</td></tr>
<tr><td><i>Ctrl+-</i></td><td>Zoom out active view</td></tr>
<tr><td><i>Ctrl+wheel</i><td></td>Zoom in/out active view</td></tr>
<tr><td><i>Shift+F4<i></td><td>Grow preview tabs on the right</td></tr>
<tr><td><i>Shift+F5<i></td><td>Grow editor tabs on the left</td></tr>
</table>
''')

    def _set_modelFileName(self, newname):
        removeTemporaryFiles(self._modelFileName)
        self._modelFileName = str(newname)
        if self.gthighlighter:
            self.gthighlighter.setDocument(None)
            del self.gthighlighter
        if self._editingGT():
            self.gthighlighter = GTHighlighter(self.editor.document())
        elif self._editingAAL():
            self.gthighlighter = AALHighlighter(self.editor.document())
        self._confFileName = None
        self.updateModelTabText()

    def _set_confFileName(self, newname):
        self._confFileName = str(newname)
        self.updateConfTabText()

    def newFile(self, path=None):
        if path and path.endswith(".aal"):
            return self.newFileAAL(path)
        self.editor.setPlainText("P(start, \"gt:istate\")\n->\n")
        self.editor.moveCursor(QtGui.QTextCursor.End)
        self.editor.setFocus()
        if not path:
            self._set_modelFileName("noname.gt")
        else:
            self._set_modelFileName(path)
        self.refreshImages()

    def newFileAAL(self, path=None):
        self.editor.setPlainText('aal "noname" {\n'
                                 '    language: python {}\n'
                                 '\n'
                                 '    # preview-hide-vars: \n'
                                 '    # preview-depth: 5\n'
                                 '    variables {\n'
                                 '        varname1, varname2\n'
                                 '    }\n'
                                 '    initial_state {\n'
                                 '        varname1 = 42      # comment1\n'
                                 '        varname2 = \'hello\' # comment2\n'
                                 '    }\n'
                                 '    action "iTestStep1()" {\n'
                                 '        guard() { return varname1 == 42 }\n'
                                 '        body()  { varname2 = \'bye\' }\n'
                                 '    }\n'
                                 '}\n')
        self.editor.moveCursor(QtGui.QTextCursor.NextWord)
        self.editor.moveCursor(QtGui.QTextCursor.NextCharacter)
        self.editor.setFocus()
        if not path:
            self._set_modelFileName("noname.py.aal")
        else:
            self._set_modelFileName(path)
        self.refreshImages()

    def newConfFile(self, path):
        self.conf_editor.setPlainText("")
        self.editor.setFocus()
        self._set_confFileName(path)
        self._doGenerateConf()

    def saveFile(self):
        if self.edit.currentIndex() == EDITTAB_GT:
            print "[saving '%s']" % (self._modelFileName,)
            file(self._modelFileName, "w").write(_deleteTrailingWhitespace(self.editor.toPlainText()))
            if self._menuOptionUpdateOnSave.isChecked():
                self.refreshImages()
        else:
            if not self._confFileName or self._confFileName.startswith(self._modelFileName):
                self.saveFileAs()
            else:
                print "[saving '%s']" % (self._confFileName,)
                file(self._confFileName, "w").write(_deleteTrailingWhitespace(self.conf_editor.toPlainText()))
                if self._menuOptionUpdateOnSave.isChecked():
                    self.refreshImages()

    def saveFileAs(self):
        fileFormats = {'gt': "fMBT GT commands (*.gt)",
                       'aal': "fMBT AAL models (*.aal)",
                       'lsts': "State machines (*.lsts)",
                       'conf': "fMBT test configuration (*.conf)",
                       '*': "All files (*.*)"}
        if self.edit.currentIndex() == EDITTAB_GT:
            dialogTitle = "Save model"
            if self._editingAAL():
                fileFormatFilters = ['aal','gt','lsts','*']
            elif self._editingLSTS():
                fileFormatFilters = ['lsts','gt','aal','*']
            elif self._editingGT():
                fileFormatFilters = ['gt','aal','lsts','*']
            else:
                fileFormatFilters = ['*']
        else:
            dialogTitle = "Save configuration"
            fileFormatFilters = ['conf', '*']

        path = QtGui.QFileDialog.getSaveFileName(self, dialogTitle, '',
                                                 ";;".join([fileFormats[n] for n in fileFormatFilters]))

        if not_using_PySide:
            newName = path
        else:
            newName = path[0]

        if str(newName) == "":
            return

        if self.edit.currentIndex() == EDITTAB_GT:
            self._set_modelFileName(newName)
        else:
            self._set_confFileName(newName)

        self.saveFile()

    def openFile(self, path=None):
        if not path:
            dialog = QtGui.QFileDialog()
            if self._fileDialogDirectory:
                dialog.setDirectory(self._fileDialogDirectory)
            else:
                dialog.setDirectory(os.getcwd())
            if self.edit.currentIndex() == EDITTAB_GT:
                dialog.setWindowTitle("Open model")
                dialog.setNameFilters(["fMBT GT commands (*.gt)","fMBT AAL models (*.aal)","State machines (*.lsts)"])
                if self._fileDialogFilter:
                    dialog.selectNameFilter(self._fileDialogFilter)
                dialog.exec_()
            else:
                dialog.setWindowTitle("Open configuration")
                dialog.setNameFilters(["fMBT test configuration (*.conf)"])
                dialog.exec_()
            if not dialog.result():
                return
            path = str(dialog.selectedFiles()[0])
            self._fileDialogDirectory = dialog.directory()
            self._fileDialogFilter = dialog.selectedNameFilter()
            del dialog
        if path:
            if isModelFile(path):
                self.editor.setPlainText(file(path).read())
                self.editor.setFocus()
                # If the configuration was not Saved As by user, generate new
                if not self._confFileName or self._confFileName.startswith(self._modelFileName):
                    self.conf_editor.setPlainText("")
                    self._confFileName = None
                    self._doGenerateConf()
                self._set_modelFileName(path)
                self.refreshImages()
            else:
                self.conf_editor.setPlainText(file(path).read())
                self.conf_editor.setFocus()
                self._set_confFileName(path)
                self.refreshImages()

    def runcmd(self, cmd):
        print cmd
        p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        try: msg_stdout = p.stdout.read()
        except: msg_stdout = ""
        try: msg_stderr = p.stderr.read()
        except: msg_stderr = ""
        print msg_stdout
        print msg_stderr
        return p.wait(), (msg_stdout, msg_stderr)

    def _editingLSTS(self):
        return self._modelFileName.endswith(".lsts") or self._modelFileName.endswith(".lts")

    def _editingAAL(self):
        return self._modelFileName.endswith(".aal")

    def _editingGT(self):
        return not self._editingLSTS() and not self._editingAAL()

    def aalPreviewArguments(self):
        show_and_hide = [[], []]
        hide_transitions = []
        hide_untraversed_transitions = []
        show_transitions = []
        show_traversed_transitions = []
        hide_states_orphaned = False
        hide_states_unvisited = False
        preview_depth = 5
        pt = str(self.editor.toPlainText())
        for show_or_hide, _, var in GT_HIDESHOWRE.findall(pt):
            correct_list = ['show', 'hide'].index(show_or_hide)
            for v in var.replace(',', ' ').split():
                show_and_hide[correct_list].append(v)
        for show_or_hide, _, regexp in GT_HIDESHOWTRANRE.findall(pt):
            if show_or_hide == 'show':
                show_transitions.append(regexp.lstrip())
            else:
                hide_transitions.append(regexp.lstrip())
        for _, regexp in GT_HIDEUNTRAVTRANRE.findall(pt):
            hide_untraversed_transitions.append(regexp.lstrip())
        for _, regexp in GT_SHOWTRAVTRANRE.findall(pt):
            show_traversed_transitions.append(regexp.lstrip())
        for fields in GT_HIDESTATES.findall(pt):
            if "orphaned" in fields:
                hide_states_orphaned = True
            if "unvisited" in fields:
                hide_states_unvisited = True
        for depth in GT_DEPTHRE.findall(pt):
            try: preview_depth = int(depth)
            except: print 'Invalid preview depth: "%s" (integer expected).' % (preview_depth,)
        return (show_and_hide, preview_depth,
                hide_transitions, hide_untraversed_transitions,
                show_transitions, show_traversed_transitions,
                hide_states_orphaned, hide_states_unvisited)

    def showError(self, errorMsg):
        self.preview_error.clear()
        if "fmbt-aalc: parsing AAL failed" in errorMsg:
            for filename, lineno, whatswrong in re.findall("^(.+):([0-9]+):(.*error.*)", errorMsg):
                if filename == self._modelFileName:
                    self.preview_error.insertHtml('<table><tr><td style="color: darkred;">AAL syntax error in file <a href="%s:%s">%s</a>, line %s</td></tr>' %
                                                  (urllib.quote(filename), lineno, filename, lineno))
                else:
                    self.preview_error.insertHtml('<table><tr><td style="color: darkred;">AAL syntax error in file %s, line %s</td></tr>' %
                                                  (filename, lineno))
                self.preview_error.insertHtml('<tr><td style="padding-left: 40 px;">%s</td></tr></table>' % (whatswrong,))
        elif "Traceback (most recent call last):" in errorMsg:
            try:
                el = errorMsg.split('\n')
                exceptionString = " " + [l for l in el[el.index("Traceback (most recent call last):")+1:]
                                         if not l.startswith("  ")][0]
            except:
                exceptionString = "Python error."
            inUserCode = False
            self.preview_error.insertHtml('<table><tr><td style="color: darkred;">%s<br>Traceback (most recent call last)</td></tr>' % (exceptionString,))
            for filename, lineno, _, location, lineofcode in re.findall('  File "([^"]+)", line ([0-9]+)(, in (.*))?\n(.*)\n', errorMsg):

                if inUserCode:
                    if filename == self._modelFileName:
                        self.preview_error.insertHtml('<tr><td style="color:darkred;">File <a href="%s:%s">%s</a>, line %s, in %s</td></tr>' %
                                                      (urllib.quote(filename), lineno, filename, lineno, location))
                    elif filename.startswith("/tmp/remote"):
                        self.preview_error.insertHtml('<tr><td style="color:darkred;">in %s</td></tr>' %
                                                      (location,))
                    else:
                        self.preview_error.insertHtml('<tr><td style="color:darkred;">File %s, line %s, in %s</td></tr>' %
                                                      (filename, lineno, location))
                    self.preview_error.insertHtml('<tr><td style="padding-left:40">%s</td></tr>' % (lineofcode,))
                # the next step will be user code, could be an included file.
                if filename.endswith("aalmodel.py") and location == "call":
                    inUserCode = True
                elif filename.endswith("remote_pyaal") and location == "<module>" and "exec" in lineofcode:
                    inUserCode = True
                print '|%s|\n>%s<\n*%s*\n\n' % (filename, location, lineofcode)
            self.preview_error.insertHtml('</table>')
        elif "parsing GT failed" in errorMsg:
            try:
                (filename, lineno, whatswrong) = re.findall("([^:]+):([0-9]+) syntax error in (.*)", errorMsg)[0]
            except: lineno = None
            if lineno:
                self.preview_error.insertHtml('<table><tr><td style="color: darkred;">GT syntax error in file <a href="%s:%s">%s</a>, line %s</td></tr>' %
                                              (urllib.quote(filename), lineno, filename, lineno))
                self.preview_error.insertHtml('<tr><td style="padding-left: 40 px;">%s</td></tr></table>' % (whatswrong,))
        self.preview_error.insertPlainText("\n\nComplete unformatted error output:\n%s" % (errorMsg,))
        self.preview_error.moveCursor(QtGui.QTextCursor.Start)
        self._previewTabBeforeError = self.preview.currentIndex()
        self.preview.setCurrentIndex(PREVIEWTAB_ERR)

    def errorItemClicked(self, qUrl):
        filename, lineno = qUrl.toString().rsplit(':',1)
        lineno = int(lineno)
        if filename == self._modelFileName:
            self.editor.moveCursor(QtGui.QTextCursor.Start)
            for _ in xrange(lineno-1):
                self.editor.moveCursor(QtGui.QTextCursor.Down, QtGui.QTextCursor.MoveAnchor)
            self.edit.setCurrentIndex(EDITTAB_GT)
            self.editor.setFocus()


    def autoSave(self):
        """
        Save unsaved contents, convert gt to lsts if possible.
        Update self._model_ok (false iff conversion fails).
        """
        saved = 0
        gt_contents = self.editor.toPlainText()
        if self._refreshed_gt != gt_contents:
            file(self._modelFileName, "w").write(_deleteTrailingWhitespace(gt_contents))
            self._refreshed_gt = gt_contents
            saved += 1
            if self._editingAAL(): # validate AAL
                self._aalcFileName = self._modelFileName + ".gted-%stmp.py" % (os.getpid(),)
                self._lstsFileName = self._modelFileName + ".gted-%stmp.lsts" % (os.getpid(),)
                # Pick up preprocessor arguments from remote_pyaal command line
                aal_ppflags = ""
                conf_lines = str(self.conf_editor.toPlainText()).split('\n')
                for l in conf_lines:
                    if "model" in l: aal_ppflags=' '.join(
                        ["'-D%s'" % f for f in re.findall('-D ?([^ ]*)', l)])
                aal2py_cmd = "fmbt-aalc %s -o '%s' %s" % (aal_ppflags, self._aalcFileName, self._modelFileName)
                executed_program = "fmbt-aalc"
                validation_exitstatus, output = self.runcmd(aal2py_cmd)
                if validation_exitstatus == 0:
                    show_hide_args = ""
                    [show_vars, hide_vars], preview_depth, _, _, _, _, _, _ = self.aalPreviewArguments()
                    for v in show_vars: show_hide_args += " -S '%s'" % (v,)
                    for v in hide_vars: show_hide_args += " -H '%s'" % (v,)
                    py2lsts_cmd = "remote_pyaal %s -o '%s'%s --lsts-depth %s '%s'" % (aal_ppflags, self._lstsFileName, show_hide_args, preview_depth, self._aalcFileName)
                    validation_exitstatus, output = self.runcmd(py2lsts_cmd)
                    if validation_exitstatus != 0:
                        self.showError(output[1])
                else: # fmbt-aalc returned an error
                    self.showError(output[1])
            elif self._editingGT(): # validate GT
                self._lstsFileName = self._modelFileName + ".gted-%stmp.lsts" % (os.getpid(),)
                gt2lsts_cmd = "fmbt-gt -o '%s' -f '%s'" % (self._lstsFileName, self._modelFileName)
                executed_program = "fmbt-gt"
                validation_exitstatus, output = self.runcmd(gt2lsts_cmd)
                if validation_exitstatus != 0:
                    self.showError(output[1])
            else: # validate LSTS (missing)
                self._lstsFileName = self._modelFileName
                validation_exitstatus = 0

            if validation_exitstatus == 0:
                self.edit.setTabIcon(0, QtGui.QIcon())
                self._model_ok = True
            elif validation_exitstatus == 127:
                error('Cannot execute "%s". Check your fMBT installation or PATH.' % (executed_program,), gui=1)
            else:
                self.edit.setTabIcon(0, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
                self._model_ok = False
        conf_contents = str(self.conf_editor.toPlainText()).strip()
        if self._refreshed_conf != conf_contents:
            if conf_contents == "":
                self._doGenerateConf()
            else:
                file(self._confFileName, "w").write(_deleteTrailingWhitespace(conf_contents))
            self._refreshed_conf = conf_contents
            saved += 2
        return saved

    def pixmapLoader(self, previewtab, filename):
        # previewtab is one of 'model', 'dist', 'cov'
        # returns function that can load an image in non-UI thread
        def loader():
            qimage_attr = 'preview_%sqimage' % (previewtab,)
            if not hasattr(self, qimage_attr):
                setattr(self, qimage_attr, QtGui.QImage())
            getattr(self, qimage_attr).load(filename)
        return loader

    def pixmapViewer(self, previewtab):
        # returns function that presents an image in a qlabel
        # must be run in UI thread
        self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_BrowserReload))
        def viewer():
            # for instance, with 'model' this calls:
            # self.preview_modelimage.setPixmap(fromImage(self.preview_modelqimage))
            # self.preview_modelcont.area.setWidget(self.preview_modelimage)
            # self.preview_modelcont.area.wheel_scale_changed()
            # self.preview.setTabIcon(PREVIEWTAB_MODEL, QtGui.QIcon())
            getattr(self, 'preview_%simage' % (previewtab,)).setPixmap(
                QtGui.QPixmap.fromImage(getattr(self, 'preview_%sqimage' % (previewtab,))))
            container = getattr(self, 'preview_%scont' % (previewtab,))
            container.area.setWidget(getattr(self, 'preview_%simage' % (previewtab,)))
            container.area.wheel_scale_changed()
            self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                    QtGui.QIcon())
        return viewer

    def pixmapUnviewable(self, previewtab):
        def errorhandler():
            self.preview.setTabIcon(eval("PREVIEWTAB_%s" % (previewtab.upper(),)),
                                    QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))
        return errorhandler

    def visualiseModel(self, change_tab = True):
        if change_tab:
            self.preview.setTabIcon(PREVIEWTAB_MODEL,
                                    QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_BrowserReload))
        self._refreshed_gt = "" # force model update
        self.autoSave()
        asyncRuncmd(self._doGenerateTest,
                    onSuccess=lambda: self.visualiseModel_havingTestGenerated(change_tab))

    def visualiseModel_havingTestGenerated(self, change_tab):
        imgname = self._modelFileName + ".gted-%stmp.states.png" % (os.getpid(),)
        logparam = []
        try: file(self._logFileName)
        except: logparam = []
        else:
            logparam.append("-l")
            logparam.append(self._logFileName)
        if self._model_ok:
            if not self._test_ok: logparam = []
            _, _, previewHideTransitions, previewHideUTransitions, previewShowTransitions, previewShowTestedTransitions, previewEraseOrphanedStates, previewEraseUnvisitedStates = self.aalPreviewArguments()
            hideparams = []
            for regexp in previewHideTransitions:
                hideparams.append("-e")
                hideparams.append(regexp)
            for regexp in previewHideUTransitions:
                hideparams.append("-E")
                hideparams.append(regexp)
            for regexp in previewShowTransitions:
                hideparams.append("-s")
                hideparams.append(regexp)
            for regexp in previewShowTestedTransitions:
                hideparams.append("-S")
                hideparams.append(regexp)
            if previewEraseOrphanedStates:
                hideparams.append("-O")
            if previewEraseUnvisitedStates:
                hideparams.append("-U")
            cmd = ["fmbt-view", "-f", "png"] + logparam + hideparams + ["-o", imgname, self._lstsFileName]
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("model", imgname),
                        onSuccess = self.pixmapViewer("model"),
                        onError = self.pixmapUnviewable("model"))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_MODEL)
            self.preview_modelimage.setFocus()
            print "display '%s'" % (imgname,)

    def plotDistribution(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._distFileName = self._modelFileName + ".gted-%stmp.dist.png" % (os.getpid(),)
            cmd = "fmbt-stats -f dist:next,sort -p '%s' -o /dev/null '%s'" % (
                self._distFileName, self._logFileName)
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("dist", self._distFileName),
                        onSuccess = self.pixmapViewer("dist"),
                        onError = self.pixmapUnviewable("dist"))

        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_DIST)
            self.preview_distimage.setFocus()
            print "display '%s'" % (self._distFileName,)

    def plotCoverage(self, change_tab = True):
        self.autoSave()
        self._doGenerateTest()
        if self._model_ok and self._test_ok:
            self._covFileName = self._modelFileName + ".gted-%stmp.cov.png" % (os.getpid(),)
            cmd = "fmbt-stats -f cov:steps -p '%s' -o /dev/null '%s'" % (
                self._covFileName, self._logFileName)
            asyncRuncmd(cmd,
                        onThreadSuccess = self.pixmapLoader("cov", self._covFileName),
                        onSuccess = self.pixmapViewer("cov"),
                        onError = self.pixmapUnviewable("cov"))
        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_COV)
            self.preview_covimage.setFocus()
            print "display '%s'" % (self._covFileName,)

    def _doGenerateConf(self):
        """ runnable in non-UI thread """
        filename = self._modelFileName
        if not self._confFileName:
            self._confFileName = self._modelFileName + ".gted-%stmp.conf" % (os.getpid(),)
        regenerate = False
        try:
            if file(self._confFileName).read().strip() == "": regenerate=True
        except: regenerate=True
        if regenerate:
            if self._editingLSTS():
                modelspec="lsts(%s)" % (self._lstsFileName,)
                lookahead = 4
            elif self._editingAAL():
                modelspec="aal_remote(remote_pyaal -l %s.gted-%stmp.aal.log '%s')" % (
                    self._modelFileName, os.getpid(), self._modelFileName)
                lookahead = 3
            else:
                modelspec="lsts_remote(fmbt-gt -f '%s')" % (self._modelFileName,)
                lookahead = 4
            file(self._confFileName, "w").write("""model     = "%s"
heuristic = "lookahead(%s)"
coverage  = "perm(2)"
pass      = "steps(20)"
on_pass   = "exit(0)"
on_fail   = "exit(1)"
on_inconc = "exit(2)"
""" % (modelspec, lookahead))

    def _doGenerateTest(self):
        """ runnable in non-UI thread """
        self._doGenerateConf()
        if not self._model_ok:
            self._test_ok = False
            return
        self._logFileName = self._modelFileName + ".gted-%stmp.log" % (os.getpid(),)
        cmd = "fmbt -l '%s' -o 'adapter=\"dummy\"' '%s'" % (self._logFileName, self._confFileName)
        fmbt_exitstatus, _ = self.runcmd(cmd)
        if fmbt_exitstatus == 0:
            self._test_ok = True
        elif fmbt_exitstatus == 127:
            error('Cannot execute "fmbt". Check you fMBT installation and PATH.',gui=0)
        else:
            self._test_ok = False

    def generateTest(self, change_tab = True):
        if change_tab:
            self.preview.setTabIcon(PREVIEWTAB_TEST,
                                    QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_BrowserReload))
        self.autoSave()
        asyncRuncmd(self._doGenerateTest,
                    onSuccess=lambda: self.generateTest_havingTestGenerated(change_tab),
                    onError = lambda: self.generateTest_havingTestGenerated(change_tab))

    def generateTest_havingTestGenerated(self, change_tab):
        if self._model_ok and self._test_ok:
            self.preview.setTabIcon(PREVIEWTAB_TEST, QtGui.QIcon())
            p = subprocess.Popen("fmbt-log -f '$sn$tv\t$ax$tr' '%s'"
                             % (self._logFileName,), shell=True, stdout=subprocess.PIPE)
            o = p.stdout.readlines()
            self.preview_test.setPlainText(''.join([l for l in o[1:]]))
        else:
            self.preview.setTabIcon(PREVIEWTAB_TEST, QtGui.qApp.style().standardIcon(QtGui.QStyle.SP_MessageBoxWarning))

        if change_tab:
            self.preview.setCurrentIndex(PREVIEWTAB_TEST)
            self.preview_test.setFocus()

    def editGT(self):
        self.edit.setCurrentIndex(EDITTAB_GT)
        self.editor.setFocus()

    def editConf(self):
        if str(self.conf_editor.toPlainText()).strip() == "":
            self._doGenerateConf()
            self.conf_editor.setPlainText(file(self._confFileName).read())
        self.edit.setCurrentIndex(EDITTAB_CONF)
        self.conf_editor.setFocus()

    def setupEditor(self):
        class TabCompletionEventFilter(QtCore.QObject):
            def __init__(self, parent):
                QtCore.QObject.__init__(self, parent)
                self.parent = parent
                self.parent._iterate_index = -1
            def eventFilter(self, obj, event):
                if event.type() != QtCore.QEvent.KeyPress: return False
                self.parent._last_keypress = time.time()
                if event.key() == QtCore.Qt.Key_Tab and self.parent.edit.currentIndex() == EDITTAB_GT:
                    self.parent._iterate_index += 1
                    self.parent.completion()
                    return True
                self.parent._iterate_index = -1
                if (event.key() == QtCore.Qt.Key_E and
                      QtGui.QApplication.keyboardModifiers() & QtCore.Qt.ControlModifier):
                    if self.parent.edit.currentIndex() == EDITTAB_GT:
                        self.parent.editor.moveCursor(QtGui.QTextCursor.EndOfLine)
                    else:
                        self.parent.conf_editor.moveCursor(QtGui.QTextCursor.EndOfLine)
                    return True
                return False
        self._keypress_eventFilter = TabCompletionEventFilter(self)

        self.mainwidget = QtGui.QWidget()
        self.layout = QtGui.QHBoxLayout()
        self.mainwidget.setLayout(self.layout)

        # Setup editor tabs
        self.edit = QtGui.QTabWidget()
        self.edit.connect(self.edit, QtCore.SIGNAL("currentChanged(int)"),
                          self.editTabChanged)

        def makeScalableEditor(parent, font, EditorClass = QtGui.QTextEdit):
            editor = EditorClass()
            editor.setUndoRedoEnabled(True)
            editor.setLineWrapMode(editor.NoWrap)
            editor.setFont(font)
            editor._scaleevents = MyScaleEvents(editor, editor, 0.1, 2.0)
            editor.wheel_scale = 1.0
            editor.wheel_scale_changed = lambda: (font.setPointSize(editor.wheel_scale * 12.0), editor.setFont(font))
            editor.installEventFilter(editor._scaleevents)
            editor.installEventFilter(self._keypress_eventFilter)
            return editor

        self.editor_font = QtGui.QFont()
        self.editor_font.setFamily('Courier')
        self.editor_font.setFixedPitch(True)
        self.editor_font.setPointSize(12)

        self.editor = makeScalableEditor(self.edit, self.editor_font)
        self.editor_tabevents = TabCompletionEventFilter(self)
        self.edit.addTab(self.editor, "GT - F1")
        self.editor.connect(self.editor, QtCore.SIGNAL("cursorPositionChanged()"),
                            self.updateModelTabText)

        self.conf_editor = makeScalableEditor(self.edit, self.editor_font)
        self.edit.addTab(self.conf_editor, "Configuration - F2")
        self.conf_editor.connect(self.conf_editor, QtCore.SIGNAL("cursorPositionChanged()"),
                                 self.updateConfTabText)

        self.gthighlighter = GTHighlighter(self.editor.document())
        self.confhighlighter = ConfHighlighter(self.conf_editor.document())

        self.splitter = QtGui.QSplitter(self.mainwidget)
        self.layout.addWidget(self.splitter,1)
        self.splitter.addWidget(self.edit)

        # Setup preview tabs
        self.preview = QtGui.QTabWidget()

        self.splitter.addWidget(self.preview)
        self._editorsOnLeft = True

        def makeScalableImage(parent, image):
            container = QtGui.QWidget(parent)
            layout = QtGui.QHBoxLayout()
            container.setLayout(layout)

            image.setSizePolicy(QtGui.QSizePolicy.Ignored, QtGui.QSizePolicy.Ignored)
            image.setScaledContents(True)
            image.resize(QtCore.QSize(0,0))

            area = QtGui.QScrollArea(container)
            area.setWidget(image)
            image._scaleevents = MyScaleEvents(area, area, 0.1, 1.0)
            area.wheel_scale = 1.0
            area.wheel_scale_changed = lambda: image.resize(area.wheel_scale * image.pixmap().size())
            area.installEventFilter(image._scaleevents)
            layout.addWidget(area)
            container.area = area
            container._layout = layout # protect from garbage collector
            return container

        self.preview_modelimage = QtGui.QLabel(self.preview)
        self.preview_modelcont = makeScalableImage(self.preview, self.preview_modelimage)
        self.preview.addTab(self.preview_modelcont, "Model - F5")

        self.preview_test = makeScalableEditor(self.preview, self.editor_font)
        self.preview.addTab(self.preview_test, "Test - F6")

        self.preview_distimage = QtGui.QLabel(self.preview)
        self.preview_distcont = makeScalableImage(self.preview, self.preview_distimage)
        self.preview.addTab(self.preview_distcont, "Distrib - F7")

        self.preview_covimage = QtGui.QLabel(self.preview)
        self.preview_covcont = makeScalableImage(self.preview, self.preview_covimage)
        self.preview.addTab(self.preview_covcont, "Coverage - F8")

        self.preview_error = makeScalableEditor(self.preview, self.editor_font, QtGui.QTextBrowser)
        self.preview_error.connect(self.preview_error, QtCore.SIGNAL("anchorClicked(QUrl)"),
                                   self.errorItemClicked)
        self.preview_error.setOpenLinks(False)
        self.preview.addTab(self.preview_error, "Errors - F9")

        self.preview.connect(self.preview, QtCore.SIGNAL("currentChanged(int)"),
                             self.previewTabChanged)

    def activeEditor(self):
        if self.editor.hasFocus():
            return self.editor
        elif self.conf_editor.hasFocus():
            return self.conf_editor
        elif self.preview_test.hasFocus():
            return self.preview_test
        elif self.preview_error.hasFocus():
            return self.preview_error
        else:
            return None

    def activeImage(self):
        if (self.preview_modelimage.hasFocus()
            or self.preview_modelcont.area.hasFocus()):
            return self.preview_modelimage
        elif (self.preview_distimage.hasFocus()
              or self.preview_distcont.area.hasFocus()):
            return self.preview_distimage
        elif (self.preview_covimage.hasFocus()
              or self.preview_covcont.area.hasFocus()):
            return self.preview_covimage
        else:
            return None

    def cutInActiveEditor(self):
        editor = self.activeEditor()
        if editor: editor.cut()

    def copyInActiveEditor(self):
        editor = self.activeEditor()
        if editor: editor.copy()

    def pasteInActiveEditor(self):
        editor = self.activeEditor()
        if editor: editor.paste()

    def zoomIn(self):
        scalable = self.activeEditor()
        if not scalable:
            scalable = self.activeImage()
        if scalable:
            scalable._scaleevents.changeScale(1.1)

    def zoomOut(self):
        scalable = self.activeEditor()
        if not scalable:
            scalable = self.activeImage()
        if scalable:
            scalable._scaleevents.changeScale(0.9)

    def updateModelTabText(self):
        self.edit.setTabText(EDITTAB_GT,"%s:%s - F1" %
                             (os.path.basename(self._modelFileName),
                              self.editor.textCursor().blockNumber() + 1))

    def updateConfTabText(self):
        if not self._confFileName or self._confFileName.startswith(self._modelFileName + ".gted"):
            captionFile = "Configuration"
        else:
            captionFile = os.path.basename(self._confFileName)
        self.edit.setTabText(EDITTAB_CONF,"%s:%s - F2" %
                             (os.path.basename(captionFile),
                              self.conf_editor.textCursor().blockNumber() + 1))

    def find(self, findFlags):
        class FindKeybShortcuts (QtCore.QObject):
            def eventFilter(_, obj, event):
                if event.type() == QtCore.QEvent.KeyPress:
                    if (event.modifiers() == QtCore.Qt.ControlModifier and
                        event.key() == QtCore.Qt.Key_F):
                        self.findNext()
                        return True
                    elif (event.modifiers() == QtCore.Qt.ControlModifier and
                          event.key() == QtCore.Qt.Key_R):
                        self.findPrev()
                        return True
                    elif event.key() == QtCore.Qt.Key_Escape:
                        self.activateWindow()
                        return False
                    else:
                        return False
                else:
                    return False

        if not hasattr(self, "findDialog"):
            self.findDialog = QtGui.QDialog()
            self.findKeybShortcuts = FindKeybShortcuts()
            self.findDialog.installEventFilter(self.findKeybShortcuts)
            self.findLayout = QtGui.QGridLayout(self.findDialog)
            self.findTextWidget = QtGui.QLineEdit(self.findDialog)
            self.findReplaceWidget = QtGui.QLineEdit(self.findDialog)
            self.findReplaceWidget.setPlaceholderText("Replace found text")
            self.findHitCounter = QtGui.QLabel("")
            self.findLayout.addWidget(QtGui.QLabel(self.findDialog, text="Find"), 0, 0)
            self.findLayout.addWidget(QtGui.QLabel(self.findDialog, text="Replace"), 1, 0)
            self.findLayout.addWidget(self.findTextWidget, 0, 1)
            self.findLayout.addWidget(self.findReplaceWidget, 1, 1)
            self.findLayout.addWidget(self.findHitCounter, 0, 2)
            self.findLayout.addWidget(
                QtGui.QLabel(self.findDialog, text="Ctrl+F: forward, Ctrl+R: reverse,"), 2, 1)
            self.findLayout.addWidget(
                QtGui.QLabel(self.findDialog, text="ESC: close"), 2, 2)
            self.findTextWidget.connect(self.findTextWidget,
                                        QtCore.SIGNAL("textEdited(QString)"),
                                        self.findTextChanged)
        if not self.findDialog.isVisible():
            self.findFrom = self.activeEditor()

            self.findReplaceWith = None
            self.findReplaceWidget.setText("")
            self.findCanReplace = None

            if self.findFrom:
                self.findFromPlainText = self.findFrom.toPlainText()
                self.findDialog.show()
                self.findDialog.raise_()
                self.findDialog.activateWindow()
                self.findTextWidget.setFocus()
        if self.findFrom:
            if self.findReplaceWidget.hasFocus() and self.findCanReplace:
                self.findFrom.insertPlainText(self.findReplaceWidget.text())
            lastFindResult = self.findFrom.find(self.findTextWidget.text(), findFlags)
            if self.findCanReplace == None or self.findCanReplace == False:
                self.findCanReplace = lastFindResult
            if self.findCanReplace and not lastFindResult and self.findReplaceWidget.hasFocus():
                self.findCanReplace = False

    def findNext(self):
        self.find(QtGui.QTextDocument.FindFlags(0))

    def findPrev(self):
        self.find(QtGui.QTextDocument.FindBackward)

    def findTextChanged(self, text):
        if text == "":
            self.findHitCounter.setText("Hits: -")
        else:
            self.findHitCounter.setText("Hits: %s" % (
                    self.findFromPlainText.count(text)))
        self.findCanReplace = None

    def editTabChanged(self, tabIndex):
        if tabIndex == EDITTAB_GT: self.editGT()
        elif tabIndex == EDITTAB_CONF: self.editConf()

    def previewTabChanged(self, tabIndex):
        if tabIndex == PREVIEWTAB_MODEL:
            self.visualiseModel(change_tab = self._previewTakeFocusOnTabChange)
        elif tabIndex == PREVIEWTAB_TEST:
            self.generateTest(change_tab = self._previewTakeFocusOnTabChange)
        elif tabIndex == PREVIEWTAB_DIST:
            self.plotDistribution(change_tab = self._previewTakeFocusOnTabChange)
        elif tabIndex == PREVIEWTAB_COV:
            self.plotCoverage(change_tab = self._previewTakeFocusOnTabChange)

    def setupFileMenu(self):
        fileMenu = QtGui.QMenu("&File", self)
        self.menuBar().addMenu(fileMenu)
        fileMenu.addAction("&New GT", self.newFile, "Ctrl+N")
        fileMenu.addAction("New AA&L", self.newFileAAL)
        fileMenu.addAction("&Open...", self.openFile, "Ctrl+O")
        fileMenu.addAction("&Save", self.saveFile, "Ctrl+S")
        fileMenu.addAction("Save &As...", self.saveFileAs)
        fileMenu.addAction("E&xit", QtGui.qApp.quit, "Ctrl+Q")

    def setupEditMenu(self):
        editMenu = QtGui.QMenu("&Edit", self)
        self.menuBar().addMenu(editMenu)
        editMenu.addAction("Cut", self.cutInActiveEditor, "Ctrl+X")
        editMenu.addAction("Copy", self.copyInActiveEditor, "Ctrl+C")
        editMenu.addAction("Paste", self.pasteInActiveEditor, "Ctrl+V")
        editMenu.addSeparator()
        editMenu.addAction("Find (next)", self.findNext, "Ctrl+F")
        editMenu.addAction("Find (previous)", self.findPrev, "Ctrl+R")

    def setupViewMenu(self):
        viewMenu = QtGui.QMenu("&View", self)
        self.menuBar().addMenu(viewMenu)
        viewMenu.addAction("Grow &editors", lambda: self.growTabs(0), "Shift+F5")
        viewMenu.addAction("Grow &previews", lambda: self.growTabs(1), "Shift+F4")
        viewMenu.addAction("Toggle editors on &top/left", self.toggleEditorsLeft, "Ctrl+T")
        viewMenu.addSeparator()
        viewMenu.addAction("Zoom in", self.zoomIn, "Ctrl++")
        viewMenu.addAction("Zoom out", self.zoomOut, "Ctrl+-")

    def setupCommandsMenu(self):
        commandMenu = QtGui.QMenu("&Commands", self)
        self.menuBar().addMenu(commandMenu)
        commandMenu.addAction("Edit &GT",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_GT),
                                       self.editor.setFocus()),
                              "F1")
        commandMenu.addAction("Edit &Configuration",
                              lambda: (self.edit.setCurrentIndex(EDITTAB_CONF),
                                       self.conf_editor.setFocus()),
                              "F2")
        commandMenu.addAction("&Visualise model",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_MODEL),
                                       self.preview_modelimage.setFocus()),
                              "F5")
        commandMenu.addAction("&Generate test",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_TEST),
                                       self.preview_test.setFocus()),
                              "F6")
        commandMenu.addAction("&Test step distribution",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_DIST),
                                       self.preview_distimage.setFocus()),
                              "F7")
        commandMenu.addAction("C&overage",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_COV),
                                       self.preview_covimage.setFocus()),
                              "F8")
        commandMenu.addAction("&Errors",
                              lambda: (self.preview.setCurrentIndex(PREVIEWTAB_ERR),
                                       self.preview_error.setFocus()),
                              "F9")
        commandMenu.addSeparator()
        self._menuOptionUpdateOnSave = QtGui.QAction("&Update preview on Save", self)
        self._menuOptionUpdateOnSave.setCheckable(True)
        self._menuOptionUpdateOnSave.setChecked(True)
        commandMenu.addAction(self._menuOptionUpdateOnSave)

    def setupHelpMenu(self):
        helpMenu = QtGui.QMenu("&Help", self)
        self.menuBar().addMenu(helpMenu)
        helpMenu.addAction("&About", self.about)

    def growTabs(self, grow):
        sizes = self.splitter.sizes()
        totalsizes = sum(sizes)
        sizes[grow] += totalsizes / 8
        sizes[1-grow] = totalsizes - sizes[grow]
        if sizes[1-grow] < totalsizes * .17:
            sizes[grow] += sizes[1-grow]
            sizes[1-grow] = 0
        self.splitter.setSizes(sizes)

    def toggleEditorsLeft(self):
        self._editorsOnLeft = not self._editorsOnLeft
        if self._editorsOnLeft:
            self.splitter.setOrientation(QtCore.Qt.Horizontal)
        else:
            self.splitter.setOrientation(QtCore.Qt.Vertical)

    def completion(self):
        if self._editingGT(): self.completionGT()
        elif self._editingAAL(): self.completionAAL()

    def completionGT(self):
        def stateActionTagNames(txt):
            snames, anames, tnames = [], [], []
            for line in txt.split('\n'):
                for (m_neg, m_src, m_act, m_dst) in TR_RE.findall(line):
                    snames.append(m_src)
                    snames.append(m_dst)
                    anames.append(m_act)
                for (m_neg, m_state, m_tag) in SP_RE.findall(line):
                    snames.append(m_state)
                    tnames.append(m_tag)
            return snames, anames, tnames
        def cursorForReplacingFromStartOfLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()
        if self._iterate_index == 0:
            _, self._anames, self._tnames = stateActionTagNames(pt)
            self._anames = list(set(self._anames))
            self._anames.sort()
            self._tnames = list(set(self._tnames))
            self._tnames.sort()
            states_above, _, _ = stateActionTagNames(pt[:pos])
            states_below, _, _ = stateActionTagNames(pt[pos:])
            states_above.reverse()
            states = states_above[:5] + states_below[:7] + states_above[5:] + states_below[7:]
            unused_states = set(states)
            uniq_states = [s for s in states
                           if s in unused_states and unused_states.remove(s) == None]
            if not uniq_states:
                self._iterate_index = -1
                return
            self._statenames = uniq_states
        curr_line = pt[:pos].split('\n')[-1]
        if curr_line.strip() == "" or (curr_line.strip().startswith("T") and not ',' in curr_line):
            # Guess source state for T(X
            if not self._statenames:
                self._iterate_index = -1
                return
            if "T" in curr_line: prefix = curr_line[:curr_line.index('T')]
            else: prefix = curr_line
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%sT(%s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 2 and ")" not in curr_line[curr_line.rindex(",")+1:]:
            # Guess destination state for T(..., ..., X
            if not self._statenames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._statenames[self._iterate_index % len(self._statenames)],))
        elif curr_line.startswith("T") and curr_line.count(",") == 1:
            # Guess action for T(..., X
            if not self._anames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._anames[self._iterate_index % len(self._anames)],))
        elif (curr_line.startswith("P") and not ',' in curr_line):
            # Guess state for P(X
            if not self._statenames:
                self._iterate_index = -1
                return
            c = cursorForReplacingFromStartOfLine()
            c.insertText("P(%s" % (self._statenames[self._iterate_index % len(self._statenames)],))
        elif (curr_line.startswith("P") and curr_line.count(',') == 1 and not ")" in curr_line):
            # Guess tag for P(..., X
            if not self._tnames:
                self._iterate_index = -1
                return
            prefix = curr_line[:curr_line.rindex(",")+1]
            c = cursorForReplacingFromStartOfLine()
            c.insertText("%s %s" % (prefix, self._tnames[self._iterate_index % len(self._tnames)]))

    def completionAAL(self):
        def parserishAAL(text, cursor):
            # search for the start of surrounding block
            subblocks = 0
            blockStartsAt = None
            openBraces = 0
            index = cursor
            blockname = None
            while blockStartsAt == None and openBraces > -1 and index > 0:
                openBraces = text.rfind('{', 0, index)
                closeBraces = text.rfind('}', 0, index)
                if openBraces > closeBraces: # found '{'
                    if subblocks == 0: blockStartsAt = openBraces
                    else:
                        subblocks -= 1
                        index = openBraces
                else: # found '}' or neither of {}
                    subblocks += 1
                    index = closeBraces
            if blockStartsAt:
                s = text[:blockStartsAt + 1]
                s = s[::-1] # reverse string
                for name, regexp in [("aal", AAL_AALREI), ("action", AAL_ACTIONREI), ("tag", AAL_TAGREI)]:
                    m = regexp.match(s)
                    if m:
                        blockname = name
                        index = blockStartsAt - m.end() + 1
                        break
            return blockname, index
        def moveCursor(suggestion):
            for _ in xrange(suggestion[1]):
                self.editor.moveCursor(QtGui.QTextCursor.Up)
            self.editor.moveCursor(QtGui.QTextCursor.EndOfLine)
            for _ in xrange(suggestion[2]):
                self.editor.moveCursor(QtGui.QTextCursor.Left)
        def cursorForReplacingWholeLine():
            c = self.editor.textCursor()
            c.clearSelection()
            c.movePosition(QtGui.QTextCursor.EndOfLine, QtGui.QTextCursor.MoveAnchor)
            c.movePosition(QtGui.QTextCursor.StartOfLine, QtGui.QTextCursor.KeepAnchor)
            return c

        if not hasattr(self, '_iterate_options') or self._iterate_index == 0:
            self._iterate_options = []

        pt = str(self.editor.toPlainText())
        pos = self.editor.textCursor().position()

        prev_lfeed = pt[:pos].rfind('\n')
        next_lfeed = pt[pos:].find('\n') + pos
        line_contents = pt[prev_lfeed:next_lfeed].strip()
        if self._iterate_index == 0 and line_contents == "":
            self._iterate_options = []
            # Tab completion suggestions for an empty line inside
            # different blocks.
            # block -> [ ("contents", cursor-up, cursor-left), ... ]
            suggestions = {
                'aal': [('action "i" {\n}', 1, 3),
                        ('tag "" {\n    guard() { return }\n}', 2, 3)],
                'action': [('guard() { return }', 0, 1),
                           ('body() {\n    \n}', 1, 0),
                           ('adapter() {\n    \n}', 1, 0)],
                'tag': [('guard() { return }', 0, 1)],
                'guard': [('return ', 0, 0)]
                }

            currentBlock, blockStartIndex = parserishAAL(pt, pos)
            if currentBlock in ['aal', 'action', 'tag', 'guard']:
                indentation_depth = blockStartIndex - pt[:blockStartIndex].rfind('\n') + 3
                for suggestion in suggestions[currentBlock]:
                    insert_text = ""
                    for line in suggestion[0].split('\n'):
                        insert_text += (' ' * indentation_depth) + (line + '\n')
                    self._iterate_options.append((insert_text[:-1], suggestion[1], suggestion[2]))
                self._iterate_options += [("", 0, 0)]
        if self._iterate_index == 0:
            # Adjust indentation.
            # If there are block-specific suggestions from above,
            # suggest only one (the most likely) indentation before
            # larger suggestions. Otherwise rotate through all
            # indentations.
            try: prev_line = pt[pt.rfind('\n',0,prev_lfeed-1):prev_lfeed]
            except Exception, e:
                self._iterate_index = -1
                return
            depth = len(prev_line) - len(prev_line.lstrip())
            if prev_line.rstrip()[-1] in ['{', ':', ',']: depth += 4
            if line_contents == '}': depth -= 4
            indentation_options = []
            for d in range(depth)[::4]:
                indentation_options.append(((" " * d) + line_contents, 0, len(line_contents)))
            indentation_options.reverse()
            if not self._iterate_options:
                self._iterate_options = indentation_options
            else:
                self._iterate_options = indentation_options[:1] + self._iterate_options
        if self._iterate_index > 0:
            # Undo previously added text.
            self.editor.document().undo()
        insert_text = ""
        suggindex = self._iterate_index % len(self._iterate_options)
        insert_text = self._iterate_options[suggindex][0]
        self.editor.textCursor().beginEditBlock()
        c = cursorForReplacingWholeLine()
        c.insertText(insert_text)
        # make sure there is always something to be undone
        c.insertText('x')
        c.deletePreviousChar()
        moveCursor(self._iterate_options[suggindex])
        self.editor.textCursor().endEditBlock()
        self.editor.ensureCursorVisible()

    def refreshImages(self):
        # if visualisation pages are hidden, don't refresh
        if self.splitter.sizes()[1] == 0: return

        self.edit.setTabIcon(EDITTAB_GT, QtGui.QIcon())
        self.edit.setTabIcon(EDITTAB_CONF, QtGui.QIcon())
        self.preview.setTabIcon(PREVIEWTAB_MODEL, QtGui.QIcon())
        self.preview.setTabIcon(PREVIEWTAB_TEST, QtGui.QIcon())
        self.preview.setTabIcon(PREVIEWTAB_DIST, QtGui.QIcon())
        self.preview.setTabIcon(PREVIEWTAB_COV, QtGui.QIcon())
        self.preview.setTabIcon(PREVIEWTAB_ERR, QtGui.QIcon())

        if self._previewTabBeforeError != None:
            self._previewTakeFocusOnTabChange = False
            self.preview.setCurrentIndex(self._previewTabBeforeError)
            self._previewTakeFocusOnTabChange = True
            self._previewTabBeforeError = None

        if self.preview.currentIndex() == PREVIEWTAB_MODEL:
            self.visualiseModel(change_tab = False)
        elif self.preview.currentIndex() == PREVIEWTAB_TEST:
            self.generateTest(change_tab = False)
        elif self.preview.currentIndex() == PREVIEWTAB_DIST:
            self.plotDistribution(change_tab = False)
        elif self.preview.currentIndex() == PREVIEWTAB_COV:
            self.plotCoverage(change_tab = False)
        elif self.preview.currentIndex() == PREVIEWTAB_ERR:
            self.preview_error.clear()

class GTHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(GTHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\bT\\b", "\\bP\\b", "->"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        usualErrorsFormat = QtGui.QTextCharFormat()
        usualErrorsFormat.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[TP]\(\""),
                usualErrorsFormat))
        self._usualErrorsFormat = usualErrorsFormat

    def highlightBlock(self, text):
        # Before coloring, check if this is a valid line
        text = str(text)
        if not TR_RE.findall(text):
            if not SP_RE.findall(text):
                if not text.startswith("#"):
                    if not text.strip() == "->":
                        self.setFormat(0, len(text), self._usualErrorsFormat)
                        self.setCurrentBlockState(0)
                        return

        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

class AALHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(AALHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = [
            "\\baal\\b", "\\blanguage\\b", "\\bvariables\\b",
            "\\binitial_state\\b", "\\badapter_init\\b",
            "\\baction\\b", "\\btag\\b",
            "\\bguard\\b", "\\bbody\\b", "\\badapter\\b"]
        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\"[^\"]*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("#[^\n]*"),
                singleLineCommentFormat))

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

class ConfHighlighter(QtGui.QSyntaxHighlighter):
    def __init__(self, parent=None):
        super(ConfHighlighter, self).__init__(parent)
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["^model\\b", "^adapter\\b", "^heuristic\\b",
                           "^coverage\\b", "^history\\b",
                           "^(on_)?(pass|fail|inconc)\\b"]

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\"[^\"]*\""),
                quotationFormat))

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.darkMagenta)
        self.highlightingRules.append((QtCore.QRegExp("^#[^\n]*"),
                singleLineCommentFormat))

        self._usualErrorsFormat = QtGui.QTextCharFormat()
        self._usualErrorsFormat.setForeground(QtCore.Qt.red)

    def highlightBlock(self, text):
        text = str(text)
        if not CF_RE.match(text):
            if not text.startswith("#"):
                self.setFormat(0, len(text), self._usualErrorsFormat)
                self.setCurrentBlockState(0)
                return
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)

            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

        self.setCurrentBlockState(0)

if __name__ == '__main__':

    app = QtGui.QApplication(sys.argv[:1] + opt_qt)
    window = MainWindow()
    window.resize(640, 512)

    if opt_modelfile:
        if not os.access(opt_modelfile, os.F_OK):
            window.newFile(opt_modelfile)
        elif os.access(opt_modelfile, os.R_OK):
            window.openFile(opt_modelfile)
        else:
            error('cannot open file "%s"' % (opt_modelfile,))

    if opt_conffile:
        if not os.access(opt_conffile, os.F_OK):
            window.newConfFile(opt_conffile)
        elif os.access(opt_modelfile, os.R_OK):
            window.openFile(opt_conffile)
        else:
            error('cannot open file "%s"' % (opt_conffile,))

    if opt_hide_preview: window.preview.hide()

    window.show()

    timer = QtCore.QTimer()
    QtCore.QTimer.singleShot(300, window.refreshImages)

    app.exec_()
    removeTemporaryFiles(window._modelFileName)
