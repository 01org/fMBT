#!/usr/bin/env python

# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.


# Example:
# fmbt-gt 'P(s0,p)->T(s0,"foo",s1)T(s1,"bar",s0)P(s1,"hello")' | lsts2dot | dotty -

"""
Usage: lsts2dot [options]
Options:
  -h, --help
          Print this help.

  -i, --input=<filename>
          Read lsts from the file. Default: standard input.

  --loops-in-states
          Print looping transitions as labels in states instead of
          drawing the loops.

  -o, --output=<filename>
          Write dot output to the file. Default: standard output.
"""

import sys
import getopt
import lsts
import subprocess

def error(msg, exit_status=1):
    sys.stderr.write("lsts2dot: %s\n" % (msg,))
    sys.exit(exit_status)

def colors(lsts_obj, testlog_fileobj):
    COLOR_ST_CANNOT_SIMULATE = "#ff00ff"
    COLOR_ST_PASS = "#80ff80"
    COLOR_ST_FAIL = "#ff8080"
    COLOR_ST_INCONC = "#c0c0c0"
    COLOR_ST_VISITED = "#e0ffe0"
    COLOR_TR_FAIL = "#c00000"
    COLOR_TR_SUGG = "#f000f0"
    COLOR_TR_EXEC = "#00c020"

    actionnames = lsts_obj.get_actionnames()
    cmd = "fmbt-log -f '$as*LSTS2DOT*$ax*LSTS2DOT*$tv'"
    p = subprocess.Popen(cmd, shell=True, stdin=testlog_fileobj.fileno(), stdout=subprocess.PIPE)

    # tr_colors dictionary maps transitions, that is (src, act, dst)
    # triplets to rgb colors
    tr_colors = {}
    state_colors = {}

    # simulate traces found in the log file in the lsts
    initial_state = int(lsts_obj.get_header().initial_states)
    current_state = initial_state
    state_colors[current_state] = COLOR_ST_VISITED
    try:
        line = p.stdout.readline()
        while line:
            action_sugg, action_exec, tv = line.strip().split('*LSTS2DOT*')
            if action_sugg == "":
                if tv == "pass":
                    state_colors[current_state] = COLOR_ST_PASS
                    current_state = initial_state
                elif tv == "inconclusive":
                    state_colors[current_state] = COLOR_ST_INCONC                    
                    current_state = initial_state
                elif tv == "fail":
                    tr_colors[sugg_tr] = COLOR_TR_FAIL
                    state_colors[current_state] = COLOR_ST_FAIL
                    current_state = initial_state
                line = p.stdout.readline()
                continue
            possible_transitions = lsts_obj.get_transitions()[current_state]
            next_state = None
            exec_tr = (0,0,0)
            sugg_tr = exec_tr
            for (dest_state, action_index) in possible_transitions:
                curr_action = actionnames[action_index]
                if action_exec == curr_action:
                    next_state = dest_state
                    exec_tr = (current_state, action_index, next_state)
                    if action_sugg == action_exec:
                        sugg_tr = exec_tr
                        break
                elif action_sugg == curr_action:
                    sugg_tr = (current_state, action_index, dest_state)
                    if not sugg_tr in tr_colors:
                        tr_colors[sugg_tr] = COLOR_TR_SUGG
            if next_state == None:
                state_colors[current_state] = COLOR_ST_CANNOT_SIMULATE
                break
            else:
                tr_colors[exec_tr] = COLOR_TR_EXEC
                current_state = next_state
                state_colors[next_state] = COLOR_ST_VISITED
            line = p.stdout.readline()
    except Exception, e:
        error('invalid line in fmbt-log -f "$ax" output: "%s"' % line[:-1])
    try: p.stdout.close()
    except: pass
    return tr_colors, state_colors

def lsts2dot(infileobj, outfileobj, loops_as_props=False, logfile = None):
    outfileobj.write('digraph g {\n')
    outfileobj.write('    node [shape=box]\n')
    l=lsts.reader(infileobj)

    if logfile != None:
        tr_colors, state_colors = colors(l, logfile)
    else:
        tr_colors, state_colors = None, None

    state2props = {int(l.get_header().initial_states): ["[initial state]"]}
    actionnames=l.get_actionnames()
    
    for propname in l.get_stateprops():
        prettyname = "[" + propname + "]"
        for state in l.get_stateprops()[propname]:
            if state in state2props:
                state2props[state].append(prettyname)
            else:
                state2props[state]=[prettyname]

    for source,outtrans in enumerate(l.get_transitions()):
        for dest,action in outtrans:
            a=actionnames[action]
            if loops_as_props and source==dest:
                if source in state2props: state2props[source].append(a)
                else: state2props[source]=[a]
            else:
                if tr_colors and (source, action, dest) in tr_colors:
                    colordata = ' color="%s"' % (tr_colors[(source, action, dest)])
                else:
                    colordata = ''
                outfileobj.write('    S%s -> S%s [label="%s"%s]\n'
                                 % (source,dest,a,colordata))

    states = state2props.keys()
    states.extend(state_colors.keys())
    states.sort()
    for state in states:
        props = state2props.get(state, [])
        props.sort()
        if state_colors and state in state_colors:
            colordata = ' fillcolor="%s" style="filled"' % (state_colors[state],)
        else:
            colordata = ''
        outfileobj.write('    S%s [label="%s\\l"%s]\n'
                         % (state,"\\l".join(props),colordata))
    outfileobj.write('}\n')

if __name__=='__main__':
    loops_as_props=False
    infile = sys.stdin
    outfile = sys.stdout
    logfile = None

    opts, remainder = getopt.getopt(
        sys.argv[1:], 'hi:o:l:',
        ['help', 'input=', 'output=', 'loops-in-states', 'log='])

    for opt, arg in opts:
        if opt in ['-h', '--help']:
            print __doc__
            sys.exit(0)
        elif opt in ['-i', '--input']:
            try: infile = file(arg, 'r')
            except Exception, e: error('cannot read file "%s": %s' % (arg, e))
        elif opt in ['-o', '--output'] and not arg in ['', '-']:
            try: outfile = file(arg, 'w')
            except Exception, e: error('cannot open file for writing "%s": %s' % (arg, e))
        elif opt == 'loops-in-states':
            loops_as_props=True
        elif opt in ['-l', '--log']:
            try: logfile = file(arg, "r")
            except Exception, e: error('cannot read file "%s": %s' % (arg, e))

    lsts2dot(infile, outfile, loops_as_props, logfile)

    try: outfile.close()
    except: pass
