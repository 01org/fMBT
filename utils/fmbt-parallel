#!/usr/bin/env python
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""
Usage: fmbt-parallel [options] component [component...]

Options:
    -s, --sync action-regexp
        all components containing an action that matches action-regexp
        execute the action synchronously. By default nothing is
        executed synchronously which corresponds to the process
        algebraic operator "|||". action-regexp ".*" corresponds to
        "||", and others to "|[ list-of-matching-actions ]|".

    -o, --output output-file
        write resulting xrules file to output-file. The default is
        standard output.
"""

import sys
import os
import re
import getopt
import fmbtparsers

def parse_actions_in_files(list_of_files):
    """
    Returns a dictionary:
        action   -> list of files where action occurs
    """
    action2filelist = {}
    current_file = None

    def add_action(s):
        if not s in action2filelist:
            action2filelist[s] = []
        action2filelist[s].append(current_file)

    # Define and set callback functions to be called when parsing a file
    def xrules_action_cb(s):
        add_action(s)

    def lts_action_cb(_, s):
        add_action(s)

    fmbtparsers.xrules_result_action(xrules_action_cb)
    fmbtparsers.lts_action(lts_action_cb)

    for current_file in list_of_files:
        if not os.access(current_file, os.R_OK):
            raise IOError("No such file: '%s'" % (current_file,))
        fmbtparsers.load(current_file)

    return action2filelist

if __name__ == "__main__":
    # Default values for commandline arguments
    sync_regexps = []
    output_file = sys.stdout

    # Parse arguments
    opts, remainder = getopt.gnu_getopt(
        sys.argv[1:], 'hvo:s:',
        ["help", "verbose", "output=", "sync="])

    for opt, arg in opts:
        if opt in ["-h", "--help"]:
            print __doc__
            sys.exit(0)
        elif opt in ["-s", "--sync"]:
            try: sync_regexps.append(re.compile(arg))
            except:
                print "Syntax error in regexp: '%s'" % (arg,)
                sys.exit(1)
        elif opt in ["-o", "--output"]:
            try: output_file = file(arg, "w")
            except Exception, e:
                print "%s" % (e,)
                sys.exit(2)

    # Read actions in files
    a2fl = parse_actions_in_files(remainder)

    # Write xrules content to output in two phases
    output = []

    # Phase 1: print file names
    for findex, fname in enumerate(remainder):
        output.append('%s = "%s"' % (findex + 1, fname))

    # Phase 2: print rules: which actions are executed synchronously,
    #          which independently of each other
    for action in sorted(a2fl.keys()):
        for regexp in sync_regexps:
            # if action matches to any regexp, execute it synchronously in every
            # file where it can be found
            if regexp.match(action):
                output.append("")
                for fname in a2fl[action]:
                    output[-1] += '(%s, "%s") ' % (remainder.index(fname) + 1, action)
                output[-1] += '-> "%s"' % (action,)
                break
        else:
            # action does not match in any regex, execute it independently in
            # every file:
            for fname in a2fl[action]:
                output.append('(%s, "%s") -> "%s"' % 
                              (remainder.index(fname) + 1, action, action))

    # Dump the output
    for l in output:
        output_file.write("%s\n" % (l,))
    output_file.close()
