#!/usr/bin/env python
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""
Usage: remote_pyaal [options] aalfile

Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc.

Options:
    -l, -L filename
        Write log to the given file. By default no log is written.
        -l overwrites the file, -L appends.

    -t, --timeout s
        Event observation timeout in seconds.
"""

import sys
import os
import getopt
import commands
import time
import fmbt

sys.path.append(os.getcwd())

log_filename = None
def log(msg):
    global log_filename
    if log_filename:
        file(log_filename,"a").write("%.4f %s\n" % (time.time(), msg))
fmbt.adapterlog = log

def error(msg):
    msg = "remote_pyaal error: " + msg + "\n"
    log(msg)
    sys.stderr.write(msg)
    sys.exit(1)

def put(msg):
    log("sending: '%s'" % (msg,))
    sys.stdout.write(str(msg) + "\n")
    sys.stdout.flush()

def put_list(list_of_integers):
    msg = " ".join([str(i) for i in list_of_integers])
    log("sending: '%s'" % (msg,))
    sys.stdout.write(msg + "\n")
    sys.stdout.flush()

def get():
    cmd = sys.stdin.readline().rstrip()
    log("received: '%s'" % (cmd,))
    return cmd

class RemoteAALBridge:
    def __init__(self, aal):
        self._aal = aal

    def communicate(self):
        # send all action names
        action_names = self._aal.getActionNames()
        for name in action_names:
            put(name)
        put("")

        # send all state tags
        tag_names = self._aal.getSPNames()
        for name in tag_names:
            put(name)
        put("")

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != "":
            if cmd == "ma":
                put_list(self._aal.getActions())
            elif cmd == "mp":
                put_list(self._aal.getprops())
            elif cmd == "mr":
                try:    self._aal.reset()
                except: put(0)
                else:   put(1)
            elif cmd == "mu":
                self._aal.push()
            elif cmd == "mo":
                self._aal.pop()
            elif cmd == "aop":
                put_list(self._aal.observe(False))
            elif cmd == "aob":
                put_list(self._aal.observe(True))
            elif cmd[0] == "m":
                action_number = int(cmd[1:])
                try:    self._aal.model_execute(action_number)
                except Exception, e:
                    log("Error on executing %s on model: %s" % (action_number, e))
                    put(0)
                else:   put(action_number)
            elif cmd[:2] == "ap":
                adapter_call_arguments.append(cmd[2:])
            elif cmd[0] == "a":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.adapter_execute(action_number,
                                                   adapter_call_arguments)
                except Exception, e:
                    log("Error on executing %s on adapter: %s" % (action_number, e))
                    put(0)
                else:   put(rv)
                adapter_call_arguments = []
            else:
                error("Unexpected command: \"" + cmd + "\". remote_pyaal works with \"aal_remote\" model.")
            cmd = get().rstrip()

if __name__ == "__main__":
    # Default values for commandline arguments
    log_filename = None
    opt_timeout = 1.0

    # Parse arguments
    opts, remainder = getopt.gnu_getopt(
        sys.argv[1:], 'hl:L:t:',
        ["help", "timeout="])

    for opt, arg in opts:
        if opt in ["-h", "--help"]:
            print __doc__
            sys.exit(0)
        elif opt in ["-l", "-L"]:
            log_filename = arg
            if opt == "-l": file(log_filename,"w") # overwrite
        elif opt in ["-t", "--timeout"]:
            opt_timeout = float(arg)
            log("observe timeout: %2.6f" % (opt_timeout,))

    if len(remainder) != 1:
        print __doc__
        error("aal filename missing")
    
    aal_filename = remainder[0]

    if aal_filename.endswith(".aal"):
        cmd = "fmbt-aalc '%s'" % (aal_filename,)
        status, aal_code = commands.getstatusoutput(cmd)
        if status != 0:
            error("converting aal to python with command\n" +
                  "    %s\nfailed. status=%s" % (cmd, status))
    else:
        try:
            aal_code = file(aal_filename).read()
        except Exception as e:
            error("reading file '%s' failed: %s" % (aal_filename, e))

    try:
        exec aal_code
    except Exception as e:
        code_lines = aal_code.split('\n')
        code_with_line_nums = ['%4s: %s' % (num+1, line)
                               for num,line in enumerate(code_lines)]
        log('\n'.join(code_with_line_nums))
        error("executing aal code failed:\n%s" % (e,))
    
    try:
        # Generated AAL code exports generated AAL class as "Model".
        # Model is inherited from AALModel in aalmodel.py.
        aal = Model()
    except Exception as e:
        error("error when instantiating Model(): %s" % (e,))
    aal._log = log
    aal.timeout = opt_timeout
    bridge = RemoteAALBridge(aal)
    bridge.communicate()
